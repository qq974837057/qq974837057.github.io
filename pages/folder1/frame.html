<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue 全流程 ✨ | 元气Blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/wind.png">
    <meta name="description" content="元气Joe的前端世界">
    
    <link rel="preload" href="/assets/css/0.styles.8a46e3d7.css" as="style"><link rel="preload" href="/assets/js/app.d50c72b0.js" as="script"><link rel="preload" href="/assets/js/2.7285e602.js" as="script"><link rel="preload" href="/assets/js/10.95e645d2.js" as="script"><link rel="prefetch" href="/assets/js/11.7a5bbaab.js"><link rel="prefetch" href="/assets/js/12.0bd756fe.js"><link rel="prefetch" href="/assets/js/13.c032609a.js"><link rel="prefetch" href="/assets/js/14.621e82f0.js"><link rel="prefetch" href="/assets/js/15.2bc7bb03.js"><link rel="prefetch" href="/assets/js/16.7b7424df.js"><link rel="prefetch" href="/assets/js/17.9a2f808e.js"><link rel="prefetch" href="/assets/js/18.2bb036cb.js"><link rel="prefetch" href="/assets/js/19.d8537971.js"><link rel="prefetch" href="/assets/js/20.c8e9e8fe.js"><link rel="prefetch" href="/assets/js/21.efec8fa1.js"><link rel="prefetch" href="/assets/js/22.3385e6bf.js"><link rel="prefetch" href="/assets/js/23.a260f1cf.js"><link rel="prefetch" href="/assets/js/24.69037aca.js"><link rel="prefetch" href="/assets/js/25.ebc4667f.js"><link rel="prefetch" href="/assets/js/26.d355b386.js"><link rel="prefetch" href="/assets/js/27.8c327e12.js"><link rel="prefetch" href="/assets/js/28.98128502.js"><link rel="prefetch" href="/assets/js/29.b35b9692.js"><link rel="prefetch" href="/assets/js/3.efa71162.js"><link rel="prefetch" href="/assets/js/30.d28a8fd7.js"><link rel="prefetch" href="/assets/js/31.2eab1cab.js"><link rel="prefetch" href="/assets/js/32.0acbefde.js"><link rel="prefetch" href="/assets/js/33.35108fd8.js"><link rel="prefetch" href="/assets/js/34.bd1353df.js"><link rel="prefetch" href="/assets/js/4.2ab80d3e.js"><link rel="prefetch" href="/assets/js/5.b6c9c262.js"><link rel="prefetch" href="/assets/js/6.d1cbcbdc.js"><link rel="prefetch" href="/assets/js/7.7f87f0fb.js"><link rel="prefetch" href="/assets/js/8.97df5136.js"><link rel="prefetch" href="/assets/js/9.80311f25.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8a46e3d7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/wind.png" alt="元气Blog" class="logo"> <span class="site-name can-hide">元气Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分类" class="dropdown-title"><span class="title">分类</span> <span class="arrow down"></span></button> <button type="button" aria-label="分类" class="mobile-dropdown-title"><span class="title">分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/folder1/html.html" class="nav-link">
  文章
</a></li><li class="dropdown-item"><!----> <a href="/pages/folder2/test4.html" class="nav-link">
  随笔
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/qq974837057" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分类" class="dropdown-title"><span class="title">分类</span> <span class="arrow down"></span></button> <button type="button" aria-label="分类" class="mobile-dropdown-title"><span class="title">分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/folder1/html.html" class="nav-link">
  文章
</a></li><li class="dropdown-item"><!----> <a href="/pages/folder2/test4.html" class="nav-link">
  随笔
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/qq974837057" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/folder1/html.html" class="sidebar-link">HTML</a></li><li><a href="/pages/folder1/css.html" class="sidebar-link">CSS</a></li><li><a href="/pages/folder1/js.html" class="sidebar-link">JS</a></li><li><a href="/pages/folder1/ts.html" class="sidebar-link">TS</a></li><li><a href="/pages/folder1/browser.html" class="sidebar-link">HTTP与浏览器</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端进阶</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/folder1/security.html" class="sidebar-link">前端安全</a></li><li><a href="/pages/folder1/monitor.html" class="sidebar-link">监控体系</a></li><li><a href="/pages/folder1/performance.html" class="sidebar-link">性能优化</a></li><li><a href="/pages/folder1/design-pattern.html" class="sidebar-link">设计模式和架构</a></li><li><a href="/pages/folder1/refactor.html" class="sidebar-link">代码重构之道</a></li><li><a href="/pages/folder1/nodejs.html" class="sidebar-link">node与前沿</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>前端框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/folder1/frame-common.html" class="sidebar-link">框架通识</a></li><li><a href="/pages/folder1/frame.html" aria-current="page" class="active sidebar-link">框架-Vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#vue-全流程-✨" class="sidebar-link">Vue 全流程 ✨</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#响应式系统" class="sidebar-link">响应式系统</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#虚拟-dom-的-diff-和-key-作用" class="sidebar-link">虚拟 DOM 的 diff 和 key 作用</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#vue-监测变化细粒度把控" class="sidebar-link">Vue 监测变化细粒度把控</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#nexttick-原理和队列" class="sidebar-link">nextTick 原理和队列</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#视图更新优化" class="sidebar-link">视图更新优化</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#vue-生命周期-✨" class="sidebar-link">Vue 生命周期 ✨</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#vue-组件通信-✨" class="sidebar-link">Vue 组件通信 ✨</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#vue-事件机制" class="sidebar-link">Vue 事件机制</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#vue-双向绑定-v-model-✨" class="sidebar-link">Vue 双向绑定 v-model ✨</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#options-✨" class="sidebar-link">options ✨</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#data-为什么是函数" class="sidebar-link">data 为什么是函数</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#不要在选项或回调上使用箭头函数" class="sidebar-link">不要在选项或回调上使用箭头函数</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#computed-和-watch-的区别" class="sidebar-link">computed 和 watch 的区别</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#常见指令-✨" class="sidebar-link">常见指令 ✨</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#v-if、v-show" class="sidebar-link">v-if、v-show</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#v-html" class="sidebar-link">v-html</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#vue2-x-检查数组变化-✨" class="sidebar-link">Vue2.x 检查数组变化 ✨</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#vue-路由" class="sidebar-link">Vue 路由</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#路由-导航-守卫" class="sidebar-link">路由(导航)守卫</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#vuex-使用和原理" class="sidebar-link">Vuex 使用和原理</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#keep-alive-✨" class="sidebar-link">keep-alive ✨</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#选项的-mixins-混入和-extends-✨" class="sidebar-link">选项的 mixins 混入和 extends ✨</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#mixins" class="sidebar-link">mixins</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#vue-mixin-mixin" class="sidebar-link">Vue.mixin(mixin)</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#extends" class="sidebar-link">extends</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#vue-extend-options" class="sidebar-link">Vue.extend(options)</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#vue3-0-重要特性-✨" class="sidebar-link">Vue3.0 重要特性 ✨</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#vue-响应式对比" class="sidebar-link">Vue 响应式对比</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#vue-2-x-响应式原理简述" class="sidebar-link">Vue 2.x 响应式原理简述</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#vue-3-x-响应式原理" class="sidebar-link">Vue 3.x 响应式原理</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#vue-的插槽理解" class="sidebar-link">Vue 的插槽理解</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#vue-动态路由方案" class="sidebar-link">Vue 动态路由方案</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#weex-架构-✨" class="sidebar-link">weex 架构 ✨</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#其他" class="sidebar-link">其他</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/folder1/frame.html#v-bind" class="sidebar-link">v-bind</a></li></ul></li></ul></li><li><a href="/pages/folder1/react.html" class="sidebar-link">框架-React</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>工程化和协作</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/folder1/webpack.html" class="sidebar-link">Webpack</a></li><li><a href="/pages/folder1/normalize.html" class="sidebar-link">前端规范</a></li><li><a href="/pages/folder1/git.html" class="sidebar-link">Git</a></li><li><a href="/pages/folder1/build.html" class="sidebar-link">构建</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>算法与编程</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/folder1/algorithm-data.html" class="sidebar-link">数据结构和算法-概念</a></li><li><a href="/pages/folder1/algorithm-sort.html" class="sidebar-link">数据结构和算法-排序专题</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="vue-全流程-✨"><a href="#vue-全流程-✨" class="header-anchor">#</a> Vue 全流程 ✨</h2> <p><img src="/assets/img/frame-vueAll1.ba7b10dd.png" alt="Vue全流程1"> <img src="/assets/img/frame-vueAll.04a1df3c.jpg" alt="Vue全流程"></p> <blockquote><p>new Vue()调用 init 初始化 -&gt; $mount 挂载 -&gt; compile()编译模板 -&gt; render function -&gt; 响应式系统 -&gt; 视图更新</p></blockquote> <blockquote><p>响应式系统：render -&gt; touch -&gt; getter -&gt; Dep 依赖收集 Watcher；setter -&gt; Dep.notify -&gt; Watcher.update() -&gt; patch()进行 diff -&gt; DOM</p></blockquote> <ul><li>分为四个阶段：初始化、挂载编译、响应式、视图更新
<ul><li>1、初始化：new Vue():调用 init 函数初始化，包括生命周期、事件、props、data、methods、watch 等，还有数据劫持，通过 Object.defineProperty 设置 setter 和 getter 函数(同时将 this.data.test 代理成 this.test)，用于后续的依赖收集和响应式。</li> <li>2、编译挂载：初始化后调用$mount 挂载组件，有 template 的情况下，内部执行 compile()编译，包括 parse（解析 template 转成 AST） 、 optimize(标记静态节点、用于 diff 优化跳过静态节点) 与 generate（AST -&gt; render function） 三个阶段，最终得到 render function，用来渲染 VNode，然后生成真实 DOM 显示在页面上。</li> <li>3、响应式：render function 被渲染，读取所需对象的值，触发 getter 函数，执行依赖收集，将订阅者 Watcher 添加 Dep 订阅器中。修改对象的值时触发 setter，通知 Dep 订阅器中的订阅者 Watcher，需要重新渲染视图，然后 Watcher 调用 update 进行更新。</li> <li>4、视图更新：数据变化触发 update 后，执行 render function 得到新的 VNode 节点，与旧的 VNode 一起传入 patch 进行比较，经过 diff 算法得到「 差异」，根据差异来修改对应的 DOM。</li></ul></li></ul> <h3 id="响应式系统"><a href="#响应式系统" class="header-anchor">#</a> 响应式系统</h3> <blockquote><p>每个 Vue 组件都有对应的一个 Watcher 实例，如果一个属性在不同组件上都使用到，将把不同组件的 Watcher 都添加到这个属性的 Dep 订阅器中，表示这些视图依赖这个对象属性，如果发生改变，这些视图都要进行更新。一个 Watcher 可能在多个 Dep 中同时存在。</p></blockquote> <ul><li><p>简述：基于[数据劫持+发布者-订阅者模式]，分三个步骤：数据劫持、依赖收集、通知订阅者进行更新</p></li> <li><p>步骤：</p> <ul><li><p>1、<strong>数据劫持</strong>：Vue 构造函数中，Object.defineProperty 遍历 Vue 上的 data 的每个属性进行劫持，添加 getter 和 setter 属性。在 vue3.0 中通过 Proxy 代理对象进行类似的操作。</p> <div class="language-js extra-class"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> descriptor<span class="token punctuation">)</span>

obj<span class="token operator">:</span>劫持对象
prop<span class="token operator">:</span>对象的属性
descriptor的属性有：
enumerable ，属性是否可枚举，默认 <span class="token boolean">false</span>。
configurable ，属性是否可以被修改或者删除，默认 <span class="token boolean">false</span>。
<span class="token keyword">get</span> ，获取属性的方法。
<span class="token keyword">set</span> ，设置属性的方法。
</code></pre></div></li> <li><p>2、<strong>依赖收集：</strong> 劫持 data 后，根据前面解析器 Compile 新建的 Watcher 订阅者实例，在执行组件渲染 render 时候，data 被 Touch(被读)，getter 函数调用，进行依赖收集，执行 dep.addSub，将 Watcher（订阅者）对象实例添加进当前属性自己的 Dep（订阅器）中进行订阅。</p></li> <li><p>3、<strong>通知订阅者进行更新</strong>：data 改动(被写)时， setter 方法被调用, 执行 dep.notify 通知自己属性的订阅器 Dep 中的每一个 Watcher 订阅者数据有变化，触发 Watcher 订阅者对象自己的 update 方法，也就是所有依赖于此 data 的组件视图去调用他们的 update 和 render 函数进行更新视图。</p></li></ul></li></ul> <h3 id="虚拟-dom-的-diff-和-key-作用"><a href="#虚拟-dom-的-diff-和-key-作用" class="header-anchor">#</a> 虚拟 DOM 的 diff 和 key 作用</h3> <p><img src="/assets/img/vue-diff.40a908fd.png" alt="vue-diff"></p> <blockquote><p>vue 和 react 的虚拟 DOM 的 Diff 算法大致相同</p></blockquote> <ul><li><p>相同：树的分层对比</p></li> <li><p>区别：节点 diff 时，react15.x 使用唯一 key 标记，且整个新老数据对比是否需要增删移，vue 使用双指针，减少节点移动次数，且组件级别采用 watcher 通知，内部采用 diff，避免 watcher 太多带来性能开销。</p></li> <li><p><a href="https://zhuanlan.zhihu.com/p/20346379" target="_blank" rel="noopener noreferrer">React diff 知乎<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li></ul> <blockquote><p>vue 的 diff 过程概述：通过 Watcher 的 update 产生新的虚拟 DOM 树，和旧虚拟 DOM 树一起传入 patch 函数，如果是 sameVnode，内容存在且不同，进行 updateChildren 更新子节点。旧层级和新层级各有两个头尾的指针变量 StartIdx 和 EndIdx，它们的 2 个变量相互比较，一共有 4 种比较方式：首首、尾尾、旧头新尾、旧尾新头，如果匹配上，指针对应的移动，如果 4 种比较都没匹配，如果设置了 key，就会用 key 进行比较。整个 diff 的过程中，两个下标往中间靠，一旦其中一个的 StartIdx&gt;EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较，将剩下的节点删除或者添加上去。</p></blockquote> <ul><li><p>过程：patch（判断子节点是否为 sameVnode）-&gt; patchVnode（sameVnode 进行对比内容是否相同）-&gt; updateChildren（更新子节点，使用双指针和 key 进行对比更新）</p></li> <li><p><strong>patch(oldVnode,vnode,parentElm)函数：比对两个 VNode 节点，将「差异」更新到视图上，也就是以旧节点为基础，进行差异修改，增删一些 DOM 节点</strong>。</p> <ul><li>旧 VNode 节点不存在，则将新 VNode 节点全部添加到父节点 parentElm 上</li> <li>新 VNode 节点不存在，则将旧 VNode 节点全部移除</li> <li><strong>旧 VNode 节点和新 VNode 节点都存在且为 sameVnode 时，进行 patchVnode 操作</strong></li></ul> <blockquote><p>sameVnode 的判断依据:key &amp;&amp; （tag &amp;&amp; 是否注释 &amp;&amp; 有无 data &amp;&amp; 若为 input 的 type 类型）</p></blockquote> <blockquote><p>因为相对来说，oldVnode 自己对应的 dom 总是已经存在的，新的 vnode 的 dom 是不存在的，直接复用 oldVnode 对应的 dom，比如直接移动 oldVnode。</p></blockquote></li> <li><p>patchVnode 操作：sameVnode 时会执行，对比两个节点的子节点是否存在，子节点不同则需要更新子节点 updateChildren，也就是进行双指针对比，进行更新下一层的节点。</p> <ul><li>新旧 VNode 节点相同，直接返回</li> <li>新旧 VNode 节点都是在解析阶段标记的静态 isStatic，且 key 相同，新的直接使用旧的内容，返回</li> <li>新 VNode 节点文本则直接设置 text，否则比较新旧 VNode 节点的孩子节点
<ul><li><strong>新旧孩子节点都存在且不同，进行最核心的 updateChildren 也就是 diff 算法 更新子节点</strong></li> <li>只有新孩子节点，将新节点全部插入父节点下</li> <li>只有旧孩子节点，没有新孩子节点，将旧节点全部清除</li></ul></li></ul></li> <li><p>updateChildren：sameVnode 且子节点存在不同，进行更新子节点。</p> <ul><li>核心 diff 算法：<strong>因为是同层的树节点进行比较，时间复杂度只需要 O(n)</strong></li> <li>例子：重复下面的对比过程，直到新旧数组中任一数组的头指针超过尾指针，循环结束 :
<ul><li>头头对比: 对比两个数组的头部，如果相同，进行 patchVnode，不需要移动 dom，直接更新属性或 Children 即可，双方头指针后移</li> <li>尾尾对比: 对比两个数组的尾部，如果相同，进行 patchVnode，不需要移动 dom，直接更新属性或 Children 即可，双方尾指针前移</li> <li>旧头新尾对比: 交叉对比，旧头新尾，如果相同，进行 patchVnode，并把旧头节点移动到旧尾节点后面，完成当前节点差异更新，新尾指针前移，旧头指针后移</li> <li>旧尾新头对比: 交叉对比，旧尾新头，如果相同，进行 patchVnode，并把旧尾节点移动到旧头节点前面，完成当前节点差异更新，旧尾指针前移，新头指针后移</li> <li>上面四种情况均不符合，则利用 key 对比: 用新指针对应节点的 key 去旧数组寻找对应的节点,这里分三种情况。
<ul><li>当没有对应的 key，那么创建新的节点，插入旧层级里，新头坐标后移一位；</li> <li>如果有对应的 key 并且是 sameVnode，两个节点进行 patchVnode，将该 key 对应的旧节点位置赋值 undefined（防止 重复 key），新头元素插入旧头元素前面，新头坐标后移一位；</li> <li>如果有对应的 key 但不是 sameVnode，则创建新节点，插入旧层级里，新头坐标后移一位。</li></ul></li></ul></li> <li>循环结束后判断两个情况：
<ul><li>旧头超过旧尾，旧数组比较完成，将新节点剩下的未遍历的节点调用 addVnodes 全部插入旧尾的真实 DOM。</li> <li>新头超过新尾，新数组比较完成，将旧节点剩下的未遍历的节点调用 removeVnodes 全部删除。</li></ul></li></ul></li> <li><p>Vue 中的 key 有什么用？</p> <ul><li>key 是 Vue 标记 vnode 的唯一 id</li> <li>作用：高效更新虚拟 dom，diff 操作更准确、更快速</li> <li>准确: 如果不加 key，对于列表中每项都是 sameVnode，那么 vue 会选择复用已经渲染好的旧节点(Vue 的就地更新策略)，导致旧节点的子孙节点被保留下来，会产生一些隐藏的 bug。</li> <li>快速: key 的唯一性可以被 Map 数据结构充分利用，相比于遍历查找的时间复杂度 O(n)，Map 的时间复杂度仅仅为 O(1)。</li> <li>举个例子：
<ul><li>比如在列表中增加 item，因为列表循环生成的节点都是 sameVnode，所以直接复用前面的旧节点，一些旧节点内容保留，可能会出现数据错位的情况，在列表最后再插入新的 item 节点。
<img src="/assets/img/vue-diff-nokey1.3443530f.png" alt="vue-diff-nokey1"> <img src="/assets/img/vue-diff-nokey2.888e87ad.png" alt="vue-diff-nokey2"></li> <li>用了 key 之后，能准确找到对应的位置，并插入，避免一些隐藏的 bug。
<img src="/assets/img/vue-diff-key.1bd23901.png" alt="vue-diff-key"></li></ul></li></ul></li> <li><p>除了key，还有什么判断相同节点</p> <ul><li>sameVnode 的判断依据:key &amp;&amp; （tag &amp;&amp; 是否注释 &amp;&amp; 有无 data &amp;&amp; 若为 input 的 type 类型）</li></ul></li> <li><p>为什么不能使用 index 做 key</p> <ul><li>使用 index 还是会导致 v-for 结束后仍然是同样的顺序，仍会就地复用旧节点。</li></ul></li></ul> <h3 id="vue-监测变化细粒度把控"><a href="#vue-监测变化细粒度把控" class="header-anchor">#</a> Vue 监测变化细粒度把控</h3> <ul><li><p>Vue 的响应式系统是中等细粒度的方案，大量的 Watcher 会使内存开销过大，大量 diff 时间太久。所以采用组件 Watcher + 内部 Diff 的方式</p> <ul><li>在组件级别进行使用 Watcher 进行监测，对 data 进行依赖收集，一旦数据变化，就知道哪个位置发生变化。</li> <li>然后在组件内部进行 Virtual Dom Diff 算法，获取更加具体节点的差异。</li></ul></li> <li><p>React 中，我们用 setState 的 API 显式更新后，React 知道发生变化后，然后暴力的 Diff 操作查找「哪发生变化了」，但是很多组件实际上是肯定不会发生变化的，这个时候需要用 shouldComponentUpdate 进行手动操作来减少 diff，从而提高程序整体的性能。</p></li> <li><p>Angular 则是脏检查操作。</p></li></ul> <h3 id="nexttick-原理和队列"><a href="#nexttick-原理和队列" class="header-anchor">#</a> nextTick 原理和队列</h3> <ul><li><p>场景：下一个循环：在 DOM 更新结束之后，执行 nextTick()中的回调，在修改数据之后，视图并不会立即更新，在下一个循环更新视图，获得更新后的 DOM，然后执行回调。</p></li> <li><p>原理：nextTick 函数传入 callback，存储到 callback 数组队列中，下一个 tick 触发时执行队列所有的 callback，清空队列。</p></li> <li><p>实现：2.6 新版本中默认优先是 microtasks,再考虑 macrotasks，都不支持则用 setTimeout。 Promise.then(microtasks)【p.then(flushCallbacks)】 -&gt; MutationObserver 的回调(microtasks) -&gt; setImmediate(ie&amp;node macrotasks) -&gt; setTimeout【setTimeout(flushCallbacks, 0)】</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 修改数据</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> <span class="token string">&quot;changed&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// DOM 还没有更新</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// DOM 现在更新了</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>全局 API</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 修改数据</span>
vm<span class="token punctuation">.</span>msg <span class="token operator">=</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// DOM 还没有更新</span>
Vue<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// DOM 更新了</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)</span>
Vue<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// DOM 更新了</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <h3 id="视图更新优化"><a href="#视图更新优化" class="header-anchor">#</a> 视图更新优化</h3> <blockquote><p>为什么频繁变化但只会更新一次（一个 number 从 0 循环增加 1000 次，只更新至最后的值）</p></blockquote> <ul><li>原理：Vue 视图更新 DOM 是异步执行的，检测到数据有变化，Vue 开启一个异步队列，下个 tick 更新视图。同一个 watcher 被多次触发，只会被推入到队列中一次。也就是说，number 的 Watcher 只会执行一次更新，就是从 0 -&gt; 1000。
<ul><li>重点：先完成 DOM 更新后，执行排在后面的 nextTick(callback)内的回调，nextTick 是用户定义的其他操作，本质都是异步队列，只是视图更新在它前面。</li> <li>执行++操作时，不断触发对应 Dep 中的 Watcher 对象的 update 方法。</li> <li>如果一个 Watcher 对象触发多次，只 push 一次进异步队列 queue 中。</li> <li>下一个循环 tick 时，触发 Watcher 对象的 run 方法(执行 patch)，执行更新 DOM 视图，number 直接从 0-&gt;1000</li></ul></li></ul> <h2 id="vue-生命周期-✨"><a href="#vue-生命周期-✨" class="header-anchor">#</a> Vue 生命周期 ✨</h2> <ul><li><p>Vue 实例从创建到销毁的过程，就是生命周期。</p></li> <li><p>从开始创建、初始化数据、编译模板、挂载 DOM → 渲染、更新 → 渲染、销毁一系列过程</p></li> <li><p>分为 4 个阶段：创建阶段(前/后), 挂载阶段(前/后), 运行阶段(更新前/后), 销毁阶段(前/后)。</p></li> <li><p>周期：前四个钩子为第一次页面加载调用。</p> <ul><li><code>beforeCreate</code>：刚创建 Vue 空实例，只有一些生命周期函数和默认事件，data、methods、el 都不可访问。</li> <li><code>created</code>：完整的实例创建好，数据劫持完成，data、methods 可访问、el 不可访问，没有生成真实 DOM。</li> <li><code>beforeMount</code>：已经完成编译模板的工作，生成一个 render function 并调用，生成虚拟 DOM 在内存中，没有生成真实 DOM。</li> <li><code>mounted</code>：完成挂载，生成真实 DOM，页面显示内容，data、method 可访问、el 可访问。</li> <li><code>beforeUpdate</code>：data 数据是新的，但页面是旧的，发生在虚拟 DOM 打补丁之前。适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</li> <li><code>updated</code>：虚拟 DOM 重新渲染和打补丁，组件真实 DOM 更新之后，页面和 data 都是最新的。更新完成后，如果有 nextTick 回调，会在视图更新后执行。</li> <li><code>beforeDestroy</code>：组件销毁前调用，实例仍然完全可用，做一些清理工作，如清除计时器，移除绑定了 DOM/BOM 对象中的事件，清理 echarts 组件 resize 的监听事件等。也可以使用 hook 监听钩子，就不需要放在对应的钩子中。<code>this.$once('hook:beforeDestroy', () =&gt; { window.removeEventListener('resize', fn) })</code></li> <li><code>destroyed</code>：组件销毁后调用，解绑指令，所有事件监听被移除（重点），所有子组件实例销毁，都不可用。</li> <li>keep-alive 在内存中保留组件的状态和元素：
<ul><li><code>activated</code>：被 keep-alive 缓存的组件专属，组件被激活时调用</li> <li><code>deactivated</code>： 被 keep-alive 缓存的组件专属，组件被销毁时调用， 可进行清理或改变数据。</li></ul></li></ul></li> <li><p>关键节点简述</p> <ul><li>创建阶段
<ul><li><code>beforeCreate</code>：【data、methods、el 均不可访问】</li> <li>中间执行：初始化 data、methods、props、computed、watcher、provide。</li> <li><code>created</code>：【data、methods 可访问、el 不可访问】【最早可访问 data】</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 允许并推荐</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>$http<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>xxx<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> res<span class="token punctuation">.</span>data
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">// 不允许</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>$el
  <span class="token keyword">this</span><span class="token punctuation">.</span>$ref<span class="token punctuation">.</span>demo
  <span class="token keyword">const</span> a <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'demo'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>挂载阶段
<ul><li><code>beforeMount</code>：【data、methods 可访问、el 不可访问】【虚拟 DOM 编译好在内存中，还未挂载】</li> <li><code>mounted</code>：【data、methods 可访问、el 可访问】【最早可操作 DOM】【页面已显示】</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 允许</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>$el
    <span class="token keyword">this</span><span class="token punctuation">.</span>$ref<span class="token punctuation">.</span>demo
    <span class="token keyword">let</span> a <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>运行阶段
<ul><li><code>beforeUpdate</code>：【数据更新后执行】【data 数据是新的，但页面是旧的】</li> <li>中间执行：<code>re-render和patch</code>进行虚拟 DOM 的 diff 和更新渲染</li> <li><code>updated</code>：【视图更新完执行】【data 和页面都是最新的】</li></ul></li> <li>销毁阶段
<ul><li><code>beforeDestroy</code>：【实例的 data、methods、指令完全可用】</li> <li><code>destroyed</code>：【实例的 data、methods、指令都不可用】</li> <li>触发销毁钩子的方法
<ul><li>手动调用<code>$destory()</code>销毁组件实例</li> <li>v-if 与 v-for 指令（v-show 不行）</li> <li>路由切换、关闭或刷新浏览器</li></ul></li></ul></li></ul></li></ul> <p><img src="/assets/img/vue-created-write.e45e7ecc.png" alt="vue-created-write"> <img src="/assets/img/vue-created.1a6c30b4.png" alt="vue-created"></p> <ul><li><p>服务器端渲染：beforeCreate、created，其他不可调用</p></li> <li><p>实践</p> <ul><li>【异步请求常放在 created】：官方推荐在 mounted 中调用，实际上可以在 created 生命周期中调用（能更快获取到服务端数据，减少页面 loading 时间）。 服务端渲染时不支持 mounted，需要放到 created 中。</li> <li>【最早访问 data】：在 created 钩子中可以对 data 数据进行操作，可以进行 ajax 请求将返回的数据赋给 data。</li> <li>【最晚修改 data】：beforeMount，此时还未挂载到页面。</li> <li>【最早操作 DOM】：在 mounted 钩子对挂载的 DOM 进行操作，此时，DOM 已经被渲染到页面上。</li> <li>【updated 函数注意】：
<ul><li>beforeUpdate 中可以改 data 吗？可以改，但不建议。在更新前改变值和更新后再次改变值，可能会导致无限更新，死循环。</li> <li>在数据变化时被触发，但不能准确的判断是那个属性值被改变，可以用 computed 或 watch 函数来监听属性的变化，并做一些其他的操作。</li></ul></li> <li>【缓存组件使用 activated】：在使用 vue-router 时有时需要使用<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>来缓存组件状态，这个时候 created 钩子就不会被重复调用了，如果我们的子组件需要在每次加载或切换状态的时候进行某些操作，可以使用 activated 钩子触发。</li> <li>所有的生命周期钩子自动绑定 this 上下文到实例中，所以不能使用箭头函数来定义一个生命周期方法 (例如 <code>created: () =&gt; this.fetchTodos()</code>)。这会导致 this 指向父级。</li></ul></li> <li><p>父子生命周期</p> <ul><li>父子组件渲染过程(子挂载完，父才算挂载完)</li></ul> <div class="language- extra-class"><pre class="language-text"><code>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;
子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted
</code></pre></div><ul><li>子组件更新过程(通过 props 传递，或者 vuex 等存在数据流向触发时)</li></ul> <div class="language- extra-class"><pre class="language-text"><code>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated
</code></pre></div><ul><li>父组件更新过程(自身组件更新，自己组件的生命周期)</li></ul> <div class="language- extra-class"><pre class="language-text"><code>父beforeUpdate-&gt;父updated
</code></pre></div><ul><li>销毁过程</li></ul> <div class="language- extra-class"><pre class="language-text"><code>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed
</code></pre></div></li> <li><p>例题：由 data 控制组件显示隐藏的生命周期过程</p> <ul><li>v-if 绑定一个组件，由 data 的 show 控制显示或隐藏<div class="language-js extra-class"><pre class="language-js"><code><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      show<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>show <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">created: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>show<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>show <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">mounted: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>show<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>show <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">nextTick: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>show<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token function">beforeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">beforeUpdate: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>show<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token function">updated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">updated: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>show<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>created 之前：data 中 show 的默认值是 true，</li> <li>created 中：show 被更改为 false，此时页面还没挂载，进入渲染。</li> <li>mounted 之前：show 为 false，根据指令编译模板，放在内存中。</li> <li>mounted 中：页面初次挂载内容，此时组件不显示。此时将 show 更改为 true，不会立即触发视图更新。</li> <li>等到下一个循环开始更新视图，触发 beforeUpdate，此时数据最新，但页面还没最新，再触发 updated，此时数据和页面都是最新，组件显示。</li> <li>视图更新完成，再执行 nextTick()中的回调函数，将 show 更改为 false，再次触发更新。</li> <li>触发 beforeUpdate，此时数据最新，但页面还没最新组件还是显示，再触发 updated，此时数据和页面都是最新，组件消失。</li> <li>最终呈现效果就是没有组件显示，刷新太快看不出来，断点调试可看到过程。<div class="language-js extra-class"><pre class="language-js"><code>created<span class="token operator">:</span> <span class="token boolean">false</span>      还未显示页面
mounted<span class="token operator">:</span> <span class="token boolean">true</span>       组件不显示
beforeUpdate<span class="token operator">:</span> <span class="token boolean">true</span>  组件不显示
updated<span class="token operator">:</span> <span class="token boolean">true</span>       组件显示
nextTick<span class="token operator">:</span> <span class="token boolean">false</span>     组件显示
beforeUpdate<span class="token operator">:</span> <span class="token boolean">false</span> 组件显示
updated<span class="token operator">:</span> <span class="token boolean">false</span>      组件消失
</code></pre></div></li></ul></li></ul> <h2 id="vue-组件通信-✨"><a href="#vue-组件通信-✨" class="header-anchor">#</a> Vue 组件通信 ✨</h2> <ul><li><p><a href="https://juejin.im/post/5d267dcdf265da1b957081a3#heading-0" target="_blank" rel="noopener noreferrer">Vue 组件通信的方法如下:<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p>总结：父子通信用<code>props/$emit</code>、兄弟组件用事件总线 <code>EventBus</code>、跨级通信使用<code>provide/inject</code>和<code>$attrs/$listeners</code>、全局使用 <code>vuex</code></p></li> <li><p>props/$emit+v-on: 父子通信：通过props将数据自上而下传递，而通过$emit 和 v-on(@)来向上传递信息。</p></li> <li><p>EventBus: 兄弟组件或跨级：事件总线：所有组件的共同事件中心，通过 EventBus 进行信息的发送和监听</p> <ul><li>不适用多人协作和大项目，较难维护。</li> <li>组件没有同时显示不应该用 eventbus，一般需要先 on 再 emit。比如两个路由一个还没创建，所以监听不到。而应该使用 vuex。</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// event-bus.js</span>

<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">&quot;vue&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> EventBus <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注册事件总线</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> EventBus <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./event-bus.js&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 组件引入</span>
EventBus<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> num<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// A组件发送事件</span>
EventBus<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">param</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// B组件接收事件</span>
EventBus<span class="token punctuation">.</span><span class="token function">$off</span><span class="token punctuation">(</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 移除监听</span>
</code></pre></div><ul><li><p>provide/inject：跨级：父组件中通过<strong>provide 来提供变量, 然后再子孙后代组件中通过 inject 来注入变</strong>量。不论组件层次有多深，并在起上下游关系成立的时间里始终生效。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">provide</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      user<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>user
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>

inject<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'user'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
</code></pre></div></li> <li><p>$attrs/$listeners: 跨级： Vue2.4 中加入的$attrs/$listeners，$attrs含有父作用域<strong>不被prop识别的特性</strong>（class和style除外），$listeners 包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器，并且可以通过 v-bind=&quot;$attrs/$listeners&quot;继续传入内部组件,传递下去。</p> <ul><li>适合仅传递数据的跨级通信，用 vuex 是大材小用。</li></ul></li> <li><p>vuex: 是全局数据管理库，可以通过 vuex 管理全局的数据流</p></li> <li><p>localStorage / sessionStorage</p> <ul><li>数据和状态比较混乱，不好维护，不过可以结合 vuex, 实现数据的持久保存</li> <li>window.localStorage.getItem(key)获取数据</li> <li>通过 window.localStorage.setItem(key,value)存储数据</li> <li>JSON.parse() / JSON.stringify() 做数据格式转换</li></ul></li></ul> <h2 id="vue-事件机制"><a href="#vue-事件机制" class="header-anchor">#</a> Vue 事件机制</h2> <ul><li>四个事件 API，分别是$on，$once，$off，$emit。</li> <li><code>$on( event, callback )</code> <ul><li>监听当前实例上的自定义事件。事件可以由 vm.$emit 触发，在模板上可使用 v-on:event=&quot;fn&quot;。</li></ul></li> <li><code>$once( event, callback )</code> <ul><li>监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除。</li></ul></li> <li><code>$off( [event, callback] )</code> <ul><li>移除自定义事件监听器。没有参数移除所有监听器；只提供了事件，则移除该事件所有的监听器；提供了事件与回调，则只移除这个回调的监听器。</li></ul></li> <li><code>$emit( eventName, […args] )</code> <ul><li>触发当前实例上的事件。附加参数都会传给监听器回调。</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code>vm<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
vm<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;hi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// =&gt; &quot;hi&quot;</span>
</code></pre></div><ul><li>手写解析：
<ul><li>on 判断事件是数组则遍历执行 on 方法，不是则将对应的 fn 回调 push 进对应事件名的事件调度中心 events 数组。</li> <li>once 封装一下 on 回调（执行一次 fn 回调时，调用 off 方法关闭监听），然后调用 on 方法将 on 回调 push 进对应事件名的事件调度中心 events 数组。</li> <li>off 判断事件是数组则遍历执行 off 方法，不是则判断有无传入 fn 回调，没传则清空该事件所有的回调函数 events 中的 fn。有传 fn 回调，则移除在 events 上对应的 fn 回调。</li> <li>emit 取出对应 events 中的 fn 回调，遍历执行所有注册的 fn 回调。</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Vue</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_events <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">$on</span><span class="token punctuation">(</span><span class="token parameter">event<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      event<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_events<span class="token punctuation">[</span>event<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_events<span class="token punctuation">[</span>event<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">$once</span><span class="token punctuation">(</span><span class="token parameter">event<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token function">on</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$off</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> on<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    on<span class="token punctuation">.</span>fn <span class="token operator">=</span> fn<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> on<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">$off</span><span class="token punctuation">(</span><span class="token parameter">event<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>arguments<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_events <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      event<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$off</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> cbs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_events<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cbs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_events<span class="token punctuation">[</span>event<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> cb<span class="token punctuation">;</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> cbs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      cb <span class="token operator">=</span> cbs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>cb <span class="token operator">===</span> fn <span class="token operator">||</span> cb<span class="token punctuation">.</span>fn <span class="token operator">===</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cbs<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">$emit</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> cbs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_events<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cbs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      cbs<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        args <span class="token operator">?</span> <span class="token function">item</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">item</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="vue-双向绑定-v-model-✨"><a href="#vue-双向绑定-v-model-✨" class="header-anchor">#</a> Vue 双向绑定 v-model ✨</h2> <p>vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同类型的标签，绑定不同的属性并传入，并抛出不同的事件：</p> <ul><li><p>input 和 textarea 元素使用 value 属性和 input 事件；</p></li> <li><p>checkbox 和 radio 使用 checked 属性和 change 事件；</p></li> <li><p>select 字段将 value 作为 prop 并将 change 作为事件。</p></li> <li><p>例子：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>something<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>

相当于绑定value属性传入组件内部，并监听组件内部emit出来的input事件

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>
  <span class="token attr-name"><span class="token namespace">v-bind:</span>value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>something<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name"><span class="token namespace">v-on:</span>input</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>something = $event.target.value<span class="token punctuation">&quot;</span></span>
<span class="token punctuation">/&gt;</span></span>
</code></pre></div></li> <li><p>自定义组件：v-model 默认会利用名为 value 的 prop 和名为 input 的事件</p> <div class="language-html extra-class"><pre class="language-html"><code>父组件：
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MyInput</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>message<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>MyInput</span><span class="token punctuation">&gt;</span></span>

子组件：
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>{{value}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>

props:{ value: String }, methods: { test() { this.$emit('input', '元气') }, }
</code></pre></div><ul><li>vue2.2 新增 model 选项，自定义 prop 和 event，就不需要限定于默认的 value 和 input。下面的 prop 是 checked，event 是 change<div class="language- extra-class"><pre class="language-text"><code>model: {
  prop: 'checked',
  event: 'change'
},
 props: {
  checked: Boolean
},
// 再使用this.$emit('change', '值')即可触发值的改变，实现双向绑定
</code></pre></div></li></ul></li></ul> <h2 id="options-✨"><a href="#options-✨" class="header-anchor">#</a> options ✨</h2> <h3 id="data-为什么是函数"><a href="#data-为什么是函数" class="header-anchor">#</a> data 为什么是函数</h3> <ul><li>组件被复用时，会创造多个实例。</li> <li>它们来自同个构造函数，如果 data 是对象，也就是引用类型，会影响到所有实例。</li> <li>为了防止实例间 data 的冲突，将 data 变为函数，用 return 返回值，让每个实例维护一份返回对象的独立拷贝。</li></ul> <h3 id="不要在选项或回调上使用箭头函数"><a href="#不要在选项或回调上使用箭头函数" class="header-anchor">#</a> 不要在选项或回调上使用箭头函数</h3> <ul><li>比如<code>created: () =&gt; console.log(this.a)</code> 或 <code>vm.$watch('a', newValue =&gt; this.myMethod())</code></li> <li>因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，会导致比如读取不到属性或者方法的错误。</li></ul> <h3 id="computed-和-watch-的区别"><a href="#computed-和-watch-的区别" class="header-anchor">#</a> computed 和 watch 的区别</h3> <ul><li>computed
<ul><li>是计算属性，依赖其他属性值来计算，将复杂逻辑放在计算属性中而不是模板。</li> <li>有缓存性，依赖属性值改变后，下次获取 computed 的值时才会重新调用对应的 getter 来计算。</li></ul></li> <li>watch
<ul><li>观察作用，基于某些数据的监听回调，深度监听对象中的属性，deep：true 选项</li> <li>无缓存性，页面重新渲染时，值不变化也会执行。</li></ul></li> <li>场景
<ul><li>依赖于其他数据的数值计算时，使用 computed</li> <li>某个数据变化时做某些异步操作（请求 API），使用 watch</li></ul></li></ul> <h2 id="常见指令-✨"><a href="#常见指令-✨" class="header-anchor">#</a> 常见指令 ✨</h2> <h3 id="v-if、v-show"><a href="#v-if、v-show" class="header-anchor">#</a> v-if、v-show</h3> <ul><li>v-if
<ul><li>v-if 如果不成立不会生成对应的 vnode，render 时不会渲染</li> <li>场景：适合条件很少变化的数据</li> <li>切换开销高</li></ul></li> <li>v-show
<ul><li>v-show 会直接生成 vnode，render 时也会被渲染，render 过程修改 display 属性值</li> <li>场景：适合频繁切换的数据</li> <li>初始开销高</li></ul></li></ul> <h3 id="v-html"><a href="#v-html" class="header-anchor">#</a> v-html</h3> <ul><li>原理：
<ul><li>v-html 移除节点所有的内容，添加 innerHTML 属性，内容为 v-html 里的内容。</li></ul></li></ul> <h2 id="vue2-x-检查数组变化-✨"><a href="#vue2-x-检查数组变化-✨" class="header-anchor">#</a> Vue2.x 检查数组变化 ✨</h2> <ul><li>总结：可用数组方法如 push/splice/unshift 或者用 Vue.set</li> <li>本质：Object.defineProperty 无法监听到数组内部变化（其实本身是可以的，只是尤大对数组没有处理）、也无法探测创建实例之后普通对象新增的属性(<code>this.myObject.newProperty = 'hi'</code>)</li> <li>方案：Vue 采用 hack 的方法实现数组监听<div class="language-js extra-class"><pre class="language-js"><code><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">unshift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">splice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li>原理：Vue 采用改变数组实例的原型对象，指向自己构造的原型对象。
<ul><li>1.将新加入的对象响应式化</li> <li>2.数组本来的 API 方法如 push、pop，通过<code>apply(this, args)</code>执行。</li> <li>3.dep.notify()提醒观察(订阅)者进行更新。</li></ul></li> <li>直接<code>vm.items[indexOfItem] = newValue</code>是无法检测到的，length 属性不能监听因为无法触发 obj 的 get 方法。</li> <li>另外的方法：
<ul><li>实例的$set方法【vm.$set( target, propertyName/index, value )】</li> <li>或者全局 API 【Vue.set( target, propertyName/index, value )】：向响应式对象中添加一个 属性 property，并确保这个新 property 同样是响应式的，且可以触发视图更新。</li></ul></li> <li>最好方案：Vue3.0 采用 Proxy 监听对象和数组</li></ul> <h2 id="vue-路由"><a href="#vue-路由" class="header-anchor">#</a> Vue 路由</h2> <ul><li><p>mode 模式有三种（页面不重新加载，只切换显示的组件）</p> <ul><li>hash：【兼容性好、URL 不美观】
<ul><li>hash 就是 URL 中#号后面的内容，改变 hash 会向浏览器添加记录。</li> <li>通过 location.hash 改变 hash，用 hashchange 监听，然后跳转，创建一个 history 保存记录自己维护，点击前进后退可切换历史 hash。</li> <li>原理：用一个 routes 对象存储路由，定义 route 方法，保存每个 hash 对应的回调方法，监听 hashchange，有变化就执行对应 location.hash 的回调函数，进行刷新。</li></ul></li> <li>history：【兼容性一般、URL 美观】
<ul><li>使用 HTML5 提供 history.pushState、history.repalceState 等 API ，不刷新页面的情况下，操作浏览器的历史记录（如新增、替换），他们都会使当前地址 URL 进行变更，区别只是有无往历史记录添加此地址。</li> <li>popstate 事件来监听 url 的变化（浏览器前进后退按钮或 JS 触发 history.back(),history.forward()等方法会触发 popstate），执行监听回调，进行页面进行跳转（渲染）</li> <li>但是 history.pushState、history.repalceState 不会触发 popstate 事件，我们需要手动触发路由的回调，进行跳转，切换显示内容。</li> <li>原理：初始化路由使用 repalceState 该路径并执行该路径的回调，定义 go 方法，执行 pushState 并手动执行回调，进行刷新。</li> <li>这个模式<strong>有坑要注意</strong>：服务器没有对应路径的资源会直接返回 404，所以需要服务器进行配置，对匹配不到的资源路径要返回 index.html，也就是我们 APP 依赖的页面，根据当前 url 匹配对应的路由，去执行对应的回调和显示。然后前端需要先配置 404 路由，放在路由列表最后。如果当所有路由匹配不到，就进入我们自己的 404 页面。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// http://mozilla.org/foo.html</span>
<span class="token keyword">let</span> stateObj <span class="token operator">=</span> <span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
history<span class="token punctuation">.</span><span class="token function">pushState</span><span class="token punctuation">(</span>stateObj<span class="token punctuation">,</span> <span class="token string">&quot;page 2&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;bar.html&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 状态对象、标题、URL路径(相对或绝对)</span>
<span class="token comment">// http://mozilla.org/bar.html, 但并不会导致浏览器加载 bar.html</span>
</code></pre></div></li> <li>abstract：没有浏览器 api，进入此模式。如 Node.js 服务器</li></ul></li> <li><p>跳转</p> <blockquote><p>Vue Router 的导航方法 (push、 replace、 go) 在各类路由模式 (history、 hash 和 abstract) 下表现一致。</p></blockquote> <ul><li>声明式<code>&lt;router-link to=&quot;&quot;&gt;&lt;/router-link&gt;</code></li> <li>编程式<code>this.$router.push('home')</code></li> <li>前进后退<code>router.go(1)/router.go(-1)</code></li> <li>替换 history 的当前记录<code>router.replace(...)</code></li></ul></li> <li><p>占位</p> <ul><li><code>&lt;router-view&gt;&lt;/router-view&gt;</code></li></ul></li> <li><p>路由懒（按需）加载</p> <ul><li>没配置路由懒加载的情况下，我们的路由组件在打包的时候，都会打包到同一个 js 文件去，导致越来越大，请求时间变长</li> <li>把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件， 首屏时不用加载过度的资源，从而减少首屏加载速度。</li> <li>import()方法由 ES6 提出，import()方法是动态加载。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// webpack&lt; 2.4 时</span>
<span class="token punctuation">{</span>
  path<span class="token operator">:</span><span class="token string">'/'</span><span class="token punctuation">,</span>
  name<span class="token operator">:</span><span class="token string">'home'</span><span class="token punctuation">,</span>
  <span class="token function-variable function">components</span><span class="token operator">:</span><span class="token parameter">resolve</span><span class="token operator">=&gt;</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'@/components/home'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>resolve<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// webpack&gt; 2.4 时</span>
<span class="token punctuation">{</span>
  path<span class="token operator">:</span><span class="token string">'/'</span><span class="token punctuation">,</span>
  name<span class="token operator">:</span><span class="token string">'home'</span><span class="token punctuation">,</span>
  <span class="token function-variable function">components</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'@/components/home'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="路由-导航-守卫"><a href="#路由-导航-守卫" class="header-anchor">#</a> 路由(导航)守卫</h3> <p>用于路由跳转前做一些逻辑处理，确定下一步要跳转的路由地址。</p> <ul><li>如全局前置守卫：beforeEach，to 表示将要跳转去的路由，from 表示正要离开的路由，next()方法用来执行 resolve 这个钩子，进行下一步跳转。
<ul><li>next() 下一个钩子，全部钩子执行完就跳转到 to 地址</li> <li>next('/') 跳到指定地址</li> <li>next(false) 中断当前导航，回到 from 地址</li> <li>next(error) 传入 error 实例，传递到 router.onError()的回调</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>应用：判断未登录则跳转去登录页</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>to<span class="token punctuation">.</span>name <span class="token operator">!==</span> <span class="token string">&quot;Login&quot;</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isAuthenticated<span class="token punctuation">)</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;Login&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>此外还有全局后置钩子 afterEach:不会接受 next 函数也不会改变导航本身</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>router<span class="token punctuation">.</span><span class="token function">afterEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="vuex-使用和原理"><a href="#vuex-使用和原理" class="header-anchor">#</a> Vuex 使用和原理</h2> <div class="language- extra-class"><pre class="language-text"><code>npm install vuex --save
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">&quot;vue&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">&quot;vuex&quot;</span><span class="token punctuation">;</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><p>简介：它是全局状态管理容器，将状态抽离到全局，集中共享管理，有几个特点：单向数据流，响应式，非持久化。通过 Vue 结合实现 store 中数据的响应式。因为保存在内存中，所有不具有持久化，默认刷新就重置状态。可通过结合缓存的方法实现持久化。
<img src="/assets/img/vue-vuex.774f934e.png" alt="vuex"></p></li> <li><p><strong>场景：中大型单页应用，项目复杂时，多个视图展示需要读取同个状态或多个视图的行为需要变更同个状态</strong></p> <ul><li>如插件中设备信息、运行数据、i18n、定时等状态信息。</li></ul></li> <li><p>使用</p> <ul><li><p>在组件中获取 Vuex 的状态，在根实例注册 store 选项，将实例先注入所有子组件，再使用 this.$store.xxx 访问，最好放在 computed 中，可以响应式监听到变化。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token punctuation">;</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> store <span class="token keyword">from</span> <span class="token string">'../store'</span>

<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  <span class="token comment">// 把 store 对象提供给 “store” 选项，把 store 的实例注入所有的子组件</span>
  store<span class="token punctuation">,</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> Counter <span class="token operator">=</span> <span class="token punctuation">{</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div&gt;{{ count }}&lt;/div&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
  computed<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">count</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>count
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//store.js</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  state<span class="token operator">:</span> <span class="token punctuation">{</span>
    count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  getters<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">countPlus</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> state<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  mutations<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">increment</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  actions<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">increment</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> commit <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">&quot;increment&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>辅助函数：mapState、mapGetters、mapMutations、mapActions，使用需要先在根节点注入 store 实例，前面已提到过。</p> <ul><li><p>使用<code>mapState、mapGetters</code>就不用一个个计算属性的写，然后用<code>...</code>展开运算符混入对应组件的 computed 中。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> mapState<span class="token punctuation">,</span> mapGetters <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  computed<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 局部组件自身计算值</span>
    <span class="token function">localComputed</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>

    <span class="token comment">// 使用对象展开运算符将 state 混入 computed 对象中</span>
    <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token comment">// ...</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token comment">// 也可传字符串数组，每个字符串表示与state同名</span>
    <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
      <span class="token comment">// ...</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span>
    <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
      <span class="token string">'doneTodosCount'</span><span class="token punctuation">,</span>
      <span class="token string">'anotherGetter'</span><span class="token punctuation">,</span>
      <span class="token comment">// ...</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token comment">// 使用 别名</span>
    <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token comment">// 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`</span>
      doneCount<span class="token operator">:</span> <span class="token string">'doneTodosCount'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>使用<code>mapMutations、mapActions</code>，将 mutation 和 action 的处理函数混入 methods，就可以直接调用<code>this.incrementBy(amount)</code>和<code>this.incrementBy1(amount)</code>，自动对应映射为<code>this.$store.commit('incrementBy', amount)</code>和 <code>this.$store.dispatch('incrementBy1', amount)</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> mapMutations<span class="token punctuation">,</span> mapActions <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  methods<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
      <span class="token string">'incrementBy'</span> <span class="token comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount) ` amount为载荷，可传参数</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      add<span class="token operator">:</span> <span class="token string">'increment'</span> <span class="token comment">// 将 `this.add()` 映射为 `this.$store.commit('increment')` add为自定义别名。</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
      <span class="token string">'incrementBy'</span> <span class="token comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      add<span class="token operator">:</span> <span class="token string">'increment'</span> <span class="token comment">// 将 `this.add()` 映射为 `this.$store.dispatch('increment')`</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li> <li><p>store.js 示例</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">&quot;vuex&quot;</span><span class="token punctuation">;</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  state<span class="token operator">:</span> <span class="token punctuation">{</span>
    deviceInfo<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    deviceDetail<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  getters<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">deviceName</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> state<span class="token punctuation">.</span>isInited <span class="token operator">?</span> state<span class="token punctuation">.</span>deviceInfo<span class="token punctuation">.</span>deviceName <span class="token operator">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">isPowerOn</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> state<span class="token punctuation">.</span>isInited <span class="token operator">&amp;&amp;</span> state<span class="token punctuation">.</span>deviceDetail<span class="token punctuation">.</span>power <span class="token operator">==</span> <span class="token string">&quot;on&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  mutations<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">setDeviceInfo</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">.</span>deviceInfo <span class="token operator">=</span> payload<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">setDeviceDetail</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">.</span>deviceDetail <span class="token operator">=</span> payload<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  actions<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 查设备信息</span>
    <span class="token keyword">async</span> <span class="token function">updateDeviceInfo</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> commit <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> nativeService
        <span class="token punctuation">.</span><span class="token function">getDeviceInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> nativeService<span class="token punctuation">.</span><span class="token function">toast</span><span class="token punctuation">(</span><span class="token string">&quot;设备信息获取失败&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">&quot;setDeviceInfo&quot;</span><span class="token punctuation">,</span> response<span class="token punctuation">.</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> response<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 查询lua状态</span>
    <span class="token keyword">async</span> <span class="token function">updateDeviceDetail</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> commit <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> isShowLoading <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> nativeService
        <span class="token punctuation">.</span><span class="token function">sendLuaRequest</span><span class="token punctuation">(</span>
          <span class="token punctuation">{</span>
            operation<span class="token operator">:</span> <span class="token string">&quot;luaQuery&quot;</span><span class="token punctuation">,</span>
            params<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span>
          isShowLoading
        <span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> nativeService<span class="token punctuation">.</span><span class="token function">toast</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">&quot;setDeviceDetail&quot;</span><span class="token punctuation">,</span> response<span class="token punctuation">.</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> response<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>state：</p> <ul><li>【状态中心】用于数据的存储，是 store 中的<strong>唯一数据源</strong>，</li> <li>【读取方式】<code>this.$store.state.A</code></li></ul></li> <li><p>getters：</p> <ul><li>【获取状态】用于数据的筛选和多个数据的相关性计算，<strong>接受 state 作为其第一个参数</strong>。基于 state 数据的二次包装，如 vue 中的 computed 属性。</li> <li>【属性读取方式】<code>this.$store.getters.B</code>，有缓存性；</li> <li>【方法读取方式】<code>this.$store.getters.fn(arg)</code>，可传参，无缓存性。</li></ul></li> <li><p>mutations：</p> <ul><li>【同步更改状态】改变 state 的<strong>唯一</strong>途径，<strong>接受 state 为第一个参数，Payload 为第二个参数</strong>，且不能处理异步事件，如果是两个异步回调的 mutations，就不知道哪个先回调了。</li> <li>【调用 1】通过 commit 调用 handler 处理函数<code>this.$store.commit('xxx', { A:'a' })</code>，commit 第二个参数为载荷 payload，作为参数传入处理函数 xxx 中，<code>xxx(state, payload){}</code>。</li> <li>【调用 2】mapMutations 辅助函数，将 mutation 的处理混入 methods，就可直接使用<code>this.xxx()</code>，会自动转为<code>this.$store.commit('xxx')</code></li></ul></li> <li><p>actions：</p> <ul><li>【异步更改状态】如接口获取最新状态，获取之后再通过调用 mutation 来进而改变 state，而不是直接变更 state。接收一个上下文 context 作为参数，在里面使用 context.commit 方法，可以使用参数解构直接使用上下文的 commit，<code>increment ({ commit }) { commit('increment') }</code>，更简洁。内部可以多个 commit 执行多个 mutation。比如根据接口返回值，决定 commit 哪一个 mutation。</li> <li>【调用 1】<code>this.$store.dispatch('xxx')</code></li> <li>【调用 2】mapActions 辅助函数，将 action 的处理混入 methods，就可直接使用<code>this.xxx()</code>，会自动转为<code>this.$store.dispatch('xxx')</code></li> <li>示例：配合<code>async/await</code> 获取设备信息成功后，commit 一个 mutation(setDeviceInfo)，将返回结果存入 state 对象对应的属性中。<div class="language-js extra-class"><pre class="language-js"><code>actions<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token keyword">async</span> <span class="token function">updateDeviceInfo</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> commit <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> nativeService<span class="token punctuation">.</span><span class="token function">getDeviceInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">err</span> <span class="token operator">=&gt;</span> nativeService<span class="token punctuation">.</span><span class="token function">toast</span><span class="token punctuation">(</span><span class="token string">'设备信息获取失败'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'setDeviceInfo'</span><span class="token punctuation">,</span> response<span class="token punctuation">.</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> response<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li> <li><p>modules：</p> <ul><li>将 store 分割成模块（module）。每个模块拥有自己的 state、getter、mutation、action，便于维护。</li> <li>模块内部的 action、mutation 和 getter 是注册在全局命名空间的，这样使得多个模块能够对同一 mutation 或 action 作出响应。可通过添加<code>namespaced: true</code>这个属性表示带命名空间的模块。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">state</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  mutations<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  actions<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  getters<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> moduleB <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">state</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  mutations<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  actions<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  modules<span class="token operator">:</span> <span class="token punctuation">{</span>
    a<span class="token operator">:</span> moduleA<span class="token punctuation">,</span>
    b<span class="token operator">:</span> moduleB
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>a <span class="token comment">// -&gt; moduleA 的状态</span>
store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>b <span class="token comment">// -&gt; moduleB 的状态</span>
</code></pre></div></li> <li><p>大型应用结构参考，分割 actions(异步逻辑封装)和 mutations(同步更改状态)</p> <div class="language-js extra-class"><pre class="language-js"><code>  ├── index<span class="token punctuation">.</span>html
  ├── main<span class="token punctuation">.</span>js
  ├── api
  │   └── <span class="token operator">...</span> # 抽取出<span class="token constant">API</span>请求
  ├── components
  │   ├── App<span class="token punctuation">.</span>vue
  │   └── <span class="token operator">...</span>
  └── store
      ├── index<span class="token punctuation">.</span>js          # 我们组装模块并导出 store 的地方
      ├── actions<span class="token punctuation">.</span>js        # 根级别的 action
      ├── mutations<span class="token punctuation">.</span>js      # 根级别的 mutation
      └── modules
          ├── cart<span class="token punctuation">.</span>js       # 购物车模块
          └── products<span class="token punctuation">.</span>js   # 产品模块
</code></pre></div></li> <li><p>vuex 结合 localStorage 持久化数据</p> <ul><li>vuex 里数据改变的时候把数据保存到 localStorage 里面</li> <li>刷新后，localStorage 里如果有保存的数据，取出来替换 store 里的 state。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> defaultCity <span class="token operator">=</span> <span class="token string">&quot;上海&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token comment">// 用户关闭了本地存储功能，此时在外层加个try...catch</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>defaultCity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    defaultCity <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">&quot;defaultCity&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  state<span class="token operator">:</span> <span class="token punctuation">{</span>
    city<span class="token operator">:</span> defaultCity<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  mutations<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">changeCity</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> city</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">.</span>city <span class="token operator">=</span> city<span class="token punctuation">;</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        window<span class="token punctuation">.</span>localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span>
          <span class="token string">&quot;defaultCity&quot;</span><span class="token punctuation">,</span>
          <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>city<span class="token punctuation">)</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 数据改变的时候把数据拷贝一份保存到localStorage里面</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>weex 中因为每个页面是独立入口，只能每个页面去引入注册 store 使用。</p></li></ul></li> <li><p>Vuex：热更新</p> <ul><li><p>让开发过程中，新增了一些 mutation 方法时，页面不会刷新，导致状态丢失</p></li> <li><p>对于 mutation 和模块，你需要使用 store.hotUpdate() 方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// store.js</span>
<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">'vuex'</span>
<span class="token keyword">import</span> mutations <span class="token keyword">from</span> <span class="token string">'./mutations'</span>
<span class="token keyword">import</span> moduleA <span class="token keyword">from</span> <span class="token string">'./modules/a'</span>

Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span>

<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>

<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  state<span class="token punctuation">,</span>
  mutations<span class="token punctuation">,</span>
  modules<span class="token operator">:</span> <span class="token punctuation">{</span>
    a<span class="token operator">:</span> moduleA
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>module<span class="token punctuation">.</span>hot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 使 action 和 mutation 成为可热重载模块</span>
  module<span class="token punctuation">.</span>hot<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'./mutations'</span><span class="token punctuation">,</span> <span class="token string">'./modules/a'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取更新后的模块</span>
    <span class="token comment">// 因为 babel 6 的模块编译格式问题，这里需要加上 `.default`</span>
    <span class="token keyword">const</span> newMutations <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./mutations'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>default
    <span class="token keyword">const</span> newModuleA <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./modules/a'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>default
    <span class="token comment">// 加载新模块</span>
    store<span class="token punctuation">.</span><span class="token function">hotUpdate</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      mutations<span class="token operator">:</span> newMutations<span class="token punctuation">,</span>
      modules<span class="token operator">:</span> <span class="token punctuation">{</span>
        a<span class="token operator">:</span> newModuleA
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li> <li><p>原理：核心就是与 Vue 本身结合，利用响应式机制，实现 store 的状态响应式。</p> <ul><li><p>混入每个 vm 实例：<code>Vue.use(Vuex)</code>安装插件，内部调用 Vuex 插件提供的 install 方法。<code>Vue.mixin({ beforeCreate: vuexInit });</code> 先将 vuexInit 混入每个实例的 beforeCreate 钩子，vuexInit 方法内部判断如果是根节点，则<code>options.store</code>赋值给 <code>this.$store</code>，否则从父节点的 <code>$store</code> 中获取。</p> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token comment">/*使用时：将 store 放入 Vue 创建时的 option 中*/</span>
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
    store
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 下面是实现</span>
<span class="token keyword">let</span> Vue<span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">install</span> <span class="token punctuation">(</span><span class="token parameter">_Vue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">{</span> beforeCreate<span class="token operator">:</span> vuexInit <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Vue <span class="token operator">=</span> _Vue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">vuexInit</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$options<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token parameter">options<span class="token punctuation">.</span>store</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>$store <span class="token operator">=</span> options<span class="token punctuation">.</span>store<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>$store <span class="token operator">=</span> options<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>$store<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>数据响应式化：通过 Vue 核心进行依赖收集，修改时更新视图。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        data<span class="token operator">:</span> <span class="token punctuation">{</span>
            $$state<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>两个 API：commit 和 dispatch</p> <ul><li>commit 方法 用于触发 mutation 。从 <code>_mutations</code> 中取出对应的 mutation，循环执行其中的每一个 mutation。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">commit</span> <span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> payload<span class="token punctuation">,</span> _options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> entry <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_mutations<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">;</span>
    entry<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">commitIterator</span> <span class="token punctuation">(</span><span class="token parameter">handler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">handler</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>dispatch 方法 用于触发 action，可以包含异步状态。取出 <code>_actions</code> 中的所有对应 action，将其执行，如果有多个则用 <code>Promise.all</code> 进行包装。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">dispatch</span> <span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> entry <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_actions<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> entry<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">1</span>
    <span class="token operator">?</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">handler</span> <span class="token operator">=&gt;</span> <span class="token function">handler</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token operator">:</span> entry<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li></ul> <h2 id="keep-alive-✨"><a href="#keep-alive-✨" class="header-anchor">#</a> keep-alive ✨</h2> <ul><li>keep-alive 是 Vue 内置的一个组件，keep-alive 可以实现组件缓存，当组件切换时不会对当前组件进行卸载，避免重新渲染 。</li> <li>提供两个属性 include/exclude：允许组件有条件的进行缓存，还有 max 属性，通过它可以设置最大缓存数
<ul><li>include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存</li> <li>exclude 的优先级比 include 高</li> <li>当缓存的实例超过设置的数 max 时，vue 会移除最久没有使用的组件缓存</li></ul></li> <li>对应两个生命周期 activated/deactivated
<ul><li>当组件被激活时，触发钩子函数 activated</li> <li>当组件被移除时，触发钩子函数 deactivated</li></ul></li> <li>原理（空间换时间）
<ul><li>keep-alive 在内部维护了一个 key 数组和一个缓存对象 cache</li> <li>key 数组记录目前缓存的组件 key 值，如果组件没有指定 key 值，会自动生成一个唯一的 key 值</li> <li><strong>cache 对象会以 key 值为键，vnode 为值，用于缓存组件对应的虚拟 DOM</strong></li> <li>在 keep-alive 的渲染函数中，逻辑是判断当前渲染的 vnode 是否有对应的缓存，如果有，会从缓存中读取到对应的组件实例，如果没有就会把它缓存起来</li> <li>当缓存的数量超过 max 设置的数值时，keep-alive 会移除 key 数组中的第一个元素</li></ul></li></ul> <h2 id="选项的-mixins-混入和-extends-✨"><a href="#选项的-mixins-混入和-extends-✨" class="header-anchor">#</a> 选项的 mixins 混入和 extends ✨</h2> <ul><li>区别：
<ul><li>【继承数量】选项 mixins 可以混入多个 mixin，extends 只能继承一个</li> <li>【优先级】 Vue.extend(挂载到某个节点) &gt; extends &gt; mixins</li> <li>【动态渲染】构造器<code>Vue.extend(options)</code>+ 实例挂载<code>vm.$mount('#demo')</code> 实现动态渲染组件到指定的 DOM 节点下</li></ul></li></ul> <h3 id="mixins"><a href="#mixins" class="header-anchor">#</a> mixins</h3> <ul><li>用来实现组件内容的复用，如埋点发送方法在多个页面都需要使用的，就可以作为 mixin 对象混入。</li> <li>使用：对象混入可以包含任意组件选项 Options，引入方式就是在 mixins 选项，放入数组中。下面是合并策略
<ul><li>data 在混入时进行【递归合并】，如果属性有冲突，以当前组件为主。</li> <li>生命周期钩子函数【合并为一个数组】：
<ul><li>同名钩子放在一起，混入的钩子要优先执行于组件自身的钩子</li> <li>如果多个对象混入，按 mixins 数组顺序执行。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> mixin1 <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;第一个打印&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> mixin2 <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;第二个打印&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  mixins<span class="token operator">:</span> <span class="token punctuation">[</span>mixin1<span class="token punctuation">,</span> mixin2<span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;第三个打印&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li>其他如 methods/components/filter/props 等，都是【合并为同个对象】，键名冲突，以组件自身键值为准。</li></ul></li></ul> <h3 id="vue-mixin-mixin"><a href="#vue-mixin-mixin" class="header-anchor">#</a> Vue.mixin(mixin)</h3> <ul><li>全局混入：在所有组件内都生效，影响到每个 Vue 实例，包括第三方组件，需要慎用。<div class="language-js extra-class"><pre class="language-js"><code>Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  methods<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
     * 将埋点方法通过全局混入添加到每个组件内部
     * 也可以将埋点方法绑定到Vue的原型链上面，如： Vue.prototype.$point = () =&gt; {}
     */</span>
    <span class="token function">point</span><span class="token punctuation">(</span><span class="token parameter">message</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <h3 id="extends"><a href="#extends" class="header-anchor">#</a> extends</h3> <ul><li>继承组件，合并策略和 mixins 一致。</li> <li>为了便于扩展单文件组件，而无需使用 Vue.extend。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 简单选项对象或构造函数</span>
<span class="token keyword">var</span> CompA <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>

<span class="token comment">// 在没有调用 `Vue.extend` 时候继承 CompA</span>
<span class="token keyword">var</span> CompB <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token keyword">extends</span><span class="token operator">:</span> CompA<span class="token punctuation">,</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="vue-extend-options"><a href="#vue-extend-options" class="header-anchor">#</a> Vue.extend(options)</h3> <ul><li>为了创建可复用的组件</li> <li><code>var fn = Vue.extend(options)</code>生成一个构造函数，参数是组件选项对象，可以用<code>new fn()</code>创建子类实例然后挂载到某个节点</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 创建构造器</span>
<span class="token keyword">var</span> Profile <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  template<span class="token operator">:</span> <span class="token string">&quot;&lt;p&gt;{{firstName}} {{lastName}} aka {{alias}}&lt;/p&gt;&quot;</span><span class="token punctuation">,</span>
  <span class="token function-variable function">data</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      firstName<span class="token operator">:</span> <span class="token string">&quot;Walter&quot;</span><span class="token punctuation">,</span>
      lastName<span class="token operator">:</span> <span class="token string">&quot;White&quot;</span><span class="token punctuation">,</span>
      alias<span class="token operator">:</span> <span class="token string">&quot;Heisenberg&quot;</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建 Profile 实例，并挂载到一个元素上。</span>
<span class="token keyword">new</span> <span class="token class-name">Profile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">&quot;#mount-point&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Walter White aka Heisenberg<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h2 id="vue3-0-重要特性-✨"><a href="#vue3-0-重要特性-✨" class="header-anchor">#</a> Vue3.0 重要特性 ✨</h2> <p>相比于 Vue2.x 主要有四方面的优势和特性：</p> <ul><li>性能更好：采用 proxy 劫持对象 和 Diff 算法优化</li> <li>体积更小：Tree-shaking</li> <li>逻辑清晰：组合式 API Composition API 将业务相关逻辑代码抽取到一起，解决代码反复横跳的问题</li></ul> <h4 id="✨proxy-与-object-defineproperty-的优劣对比"><a href="#✨proxy-与-object-defineproperty-的优劣对比" class="header-anchor">#</a> ✨Proxy 与 Object.defineProperty 的优劣对比?</h4> <ul><li>基于数据劫持的双向绑定有两种实现
<ul><li>一个是目前 Vue2 在用的 Object.defineProperty</li> <li>另一个是 Vue3.0 加入的 ES2015 中新增的 Proxy<code>const proxy = new Proxy(target, handler)</code></li></ul></li> <li>Proxy 的优势
<ul><li>可以直接监听对象(Object.defineProperty 遍历对象里面的属性，属性是对象还得深度遍历)</li> <li>可以直接监听数组的变化(Object.defineProperty 其实是可以监听数组的，只是尤大说性价比不高，数组元素比较多，容易影响性能)</li> <li>有多种拦截方法：如 has、deleteProperty</li> <li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化</li> <li>缺点：浏览器兼容性不如 Object.defineProperty 好</li></ul></li> <li>Object.defineProperty 的优势:
<ul><li>兼容性好,支持 IE9(不能兼容 IE8 及以下)。而 Proxy 的存在浏览器兼容性问题，且无法用 polyfill 磨平，所以在 Vue3.0 才能引入这个破坏性改变。</li> <li>缺点：只能劫持对象的属性,需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历。</li></ul></li></ul> <h4 id="diff-算法优化"><a href="#diff-算法优化" class="header-anchor">#</a> Diff 算法优化</h4> <ul><li><p>Diff 算法优化【PatchFlags 类型标志 + 模板传入的事件缓存起来 cacheHandlers 不会重复渲染】</p> <ul><li>针对类型高效地 diff：在创建 VNode 时就确定其类型，_createVNode 传入数字表示是 text(1)还是 props(8)，无数字则表示静态，不需要 diff。通过位运算来判断有多种类型组合 VNode 的类型，按位与(组合值)&amp;(类型的值)就可以得出是由哪些类型组合而成的，针对那些类型进行 diff 即可。</li> <li>类型数值</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token keyword">enum</span> PatchFlags <span class="token punctuation">{</span>

  <span class="token constant">TEXT</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token comment">// 表示具有动态textContent的元素</span>
  <span class="token constant">CLASS</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token comment">// 表示有动态Class的元素</span>
  <span class="token constant">STYLE</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token comment">// 表示动态样式（静态如style=&quot;color: red&quot;，也会提升至动态）</span>
  <span class="token constant">PROPS</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">,</span>  <span class="token comment">// 表示具有非类/样式动态道具的元素。</span>
  <span class="token constant">FULL_PROPS</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">,</span>  <span class="token comment">// 表示带有动态键的道具的元素，与上面三种相斥</span>
  <span class="token constant">HYDRATE_EVENTS</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">5</span><span class="token punctuation">,</span>  <span class="token comment">// 表示带有事件监听器的元素</span>
  <span class="token constant">STABLE_FRAGMENT</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">6</span><span class="token punctuation">,</span>   <span class="token comment">// 表示其子顺序不变的片段（没懂）。</span>
  <span class="token constant">KEYED_FRAGMENT</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token comment">// 表示带有键控或部分键控子元素的片段。</span>
  <span class="token constant">UNKEYED_FRAGMENT</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token comment">// 表示带有无key绑定的片段</span>
  <span class="token constant">NEED_PATCH</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">9</span><span class="token punctuation">,</span>   <span class="token comment">// 表示只需要非属性补丁的元素，例如ref或hooks</span>
  <span class="token constant">DYNAMIC_SLOTS</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">10</span><span class="token punctuation">,</span>  <span class="token comment">// 表示具有动态插槽的元素</span>
<span class="token punctuation">}</span>

<span class="token comment">// 组合示例</span>
<span class="token keyword">let</span> <span class="token constant">TEXT</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">STYLE</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token constant">PROPS</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
<span class="token number">1</span><span class="token operator">^</span><span class="token number">8</span> <span class="token operator">=</span> <span class="token number">9</span> <span class="token comment">// “异或”组合,存在text和props类型</span>
<span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token number">9</span> <span class="token operator">&amp;</span> <span class="token constant">TEXT</span><span class="token punctuation">)</span>  <span class="token comment">// true “按位与”检查是否有该类型</span>
<span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token number">9</span> <span class="token operator">&amp;</span> <span class="token constant">PROPS</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
<span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token number">9</span> <span class="token operator">&amp;</span> <span class="token constant">STYLE</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
</code></pre></div><ul><li><a href="https://juejin.im/post/5e9faa8fe51d4546fe263eda" target="_blank" rel="noopener noreferrer">蜗牛老湿<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul> <h4 id="composition-api"><a href="#composition-api" class="header-anchor">#</a> Composition API</h4> <p>setup 是 Composition API 的入口函数，是在 beforeCreate 声明周期函数之前执行的。还提供了 ref 函数定义一个响应式的数据，reactive 函数定义多个数据的响应式等等。</p> <p><img src="https://composition-api.vuejs.org/zh/#%E6%A6%82%E8%BF%B0" alt="组合式API-RFC"></p> <ul><li><p>使用示例：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>increment<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    Count is: {{ state.count }}, double is: {{ state.double }}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">import</span> <span class="token punctuation">{</span> reactive<span class="token punctuation">,</span> computed <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;vue&quot;</span><span class="token punctuation">;</span>

  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token comment">// 原data返回的对象实质也是通过这个方法变成响应式的，因为可以和options选项混用。</span>
        count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
        double<span class="token operator">:</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        state<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        state<span class="token punctuation">,</span>
        increment<span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>组合式 API</p> <ul><li><p>简单理解：</p> <ul><li><p>组合：将 data、computed、method、生命周期等集中在 setup()函数中，setup 函数里可以存放多个组合函数，根据传递的参数可以清晰看到每个组合函数之间的依赖关系，通过逻辑关系组织代码，避免逻辑点分散开，通过 return 单一出口暴露的方式，把属性和方法给模板使用。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...存放多个组合函数</span>
    <span class="token comment">// 网络状态</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> networkState <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useNetworkState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 文件夹状态</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> folders<span class="token punctuation">,</span> currentFolderData <span class="token punctuation">}</span> <span class="token operator">=</span>
      <span class="token function">useCurrentFolderData</span><span class="token punctuation">(</span>networkState<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> folderNavigation <span class="token operator">=</span> <span class="token function">useFolderNavigation</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      networkState<span class="token punctuation">,</span>
      currentFolderData<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> createFolder <span class="token operator">=</span> <span class="token function">useCreateFolder</span><span class="token punctuation">(</span>folderNavigation<span class="token punctuation">.</span>openFolder<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 编写单个组合函数</span>
<span class="token keyword">function</span> <span class="token function">useCreateFolder</span><span class="token punctuation">(</span><span class="token parameter">openFolder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 参数是另一个方法</span>
  <span class="token comment">// 原来的数据 property</span>
  <span class="token keyword">const</span> showNewFolder <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> newFolderName <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 原来的计算属性</span>
  <span class="token keyword">const</span> newFolderValid <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
    <span class="token function">isValidMultiName</span><span class="token punctuation">(</span>newFolderName<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 原来的一个方法</span>
  <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">createFolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token function">openFolder</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>data<span class="token punctuation">.</span>folderCreate<span class="token punctuation">.</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
    newFolderName<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
    showNewFolder<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 暴露出去</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    showNewFolder<span class="token punctuation">,</span>
    newFolderName<span class="token punctuation">,</span>
    newFolderValid<span class="token punctuation">,</span>
    createFolder<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>复用：同时让提取和复用变得简单，编写一个用组合式 API 的函数，暴露出去，在 setup()直接引入该函数并解构获取属性/方法即可，不需要再创建组件实例 mixin 去混入，解决属性来源不清晰的问题，还可以通过解构消除 mixin 带来的命名空间冲突。</p> <ul><li>一个组合函数</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> onMounted<span class="token punctuation">,</span> onUnmounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;vue&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">useMousePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> y <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">.</span>value <span class="token operator">=</span> e<span class="token punctuation">.</span>pageX<span class="token punctuation">;</span>
    y<span class="token punctuation">.</span>value <span class="token operator">=</span> e<span class="token punctuation">.</span>pageY<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;mousemove&quot;</span><span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">onUnmounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    window<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;mousemove&quot;</span><span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p>混入</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useMousePosition <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./mouse&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useMousePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 其他逻辑...</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li></ul></li> <li><p>可与现有的 选项 Options API 一起使用</p> <ul><li>组合式 API 会在 2.x 的选项 (data、computed 和 methods) 之前解析，并且不能提前访问这些选项中定义的 property。</li> <li>setup() 函数返回的 property 将会被暴露给 this</li></ul></li> <li><p>灵活的逻辑组合与复用，混入(mixin) 将不再作为推荐使用</p></li> <li><p>Composition API 的入口 setup()</p> <ul><li>Vue 创建组件实例，然后初始化 props ，紧接着就调用 setup 函数，在 beforeCreate 钩子之前被调用。</li> <li>this 在 setup() 中不可用，因为 this 和 2.x 的选项不同。</li> <li>使用方式</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span> count <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> object<span class="token punctuation">.</span>foo <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
  <span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> reactive <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token keyword">const</span> object <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token string">'bar'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">//在组件中从 data() 返回一个对象，内部实质上通过调用 reactive() 使其变为响应式。</span>

      <span class="token comment">// 返回对象暴露给模板</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        count<span class="token punctuation">,</span>
        object<span class="token punctuation">,</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div></li> <li><p>主要有六个 API</p> <ul><li>reactive：将传入的对象变成响应式，是深度转换的</li> <li>ref：用来初始化属性，返回一个响应式且可改变的 ref 对象，内部有唯一属性 value，不过在模板不需要写 value 属性，会自动解开。<code>const showNewFolder = ref(false)</code></li> <li>computed：可传入 get 和 set，返回 ref 对象</li> <li>readonly：传入一个对象（响应式或普通）或 ref，返回一个原始对象的只读代理。深层的属性也是只读的。</li> <li>watchEffect：传入的函数被立即执行，当更新时候再继续执行</li> <li>watch：对比上面 watchEffect，是懒执行的。只有监听到变化才执行回调函数。</li></ul></li> <li><p>生命周期对应</p> <ul><li>beforeCreate -&gt; 使用 setup()</li> <li>created -&gt; 使用 setup()</li> <li>beforeMount -&gt; onBeforeMount</li> <li>mounted -&gt; onMounted</li> <li>beforeUpdate -&gt; onBeforeUpdate</li> <li>updated -&gt; onUpdated</li> <li>beforeDestroy -&gt; onBeforeUnmount</li> <li>destroyed -&gt; onUnmounted</li> <li>errorCaptured -&gt; onErrorCaptured</li></ul></li> <li><p>使用方式：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> onMounted<span class="token punctuation">,</span> onUpdated<span class="token punctuation">,</span> onUnmounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;vue&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;mounted!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">onUpdated</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;updated!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">onUnmounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;unmounted!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>注意：生命周期钩子注册函数只能在 setup() 期间同步使用， 因为它们依赖于内部的全局状态来定位当前组件实例（正在调用 setup() 的组件实例）, 不在当前组件下调用这些函数会抛出一个错误。</p> <ul><li>逻辑提取与复用</li></ul></li></ul></li></ul> <h4 id="tree-shaking"><a href="#tree-shaking" class="header-anchor">#</a> Tree-shaking</h4> <p>编译时用 import 按需引入，没有使用就不会打包，配合 webpack 的 Tree-shaking，实现更小的体积 10-20kb</p> <h2 id="vue-响应式对比"><a href="#vue-响应式对比" class="header-anchor">#</a> Vue 响应式对比</h2> <h3 id="vue-2-x-响应式原理简述"><a href="#vue-2-x-响应式原理简述" class="header-anchor">#</a> Vue 2.x 响应式原理简述</h3> <ul><li>Vue 在初始化数据时，会使用 Object.defineProperty 重新定义 data 中的所有属性，当开始渲染时，首先会进行依赖收集(收集当前组件的 watcher)，如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。</li></ul> <h3 id="vue-3-x-响应式原理"><a href="#vue-3-x-响应式原理" class="header-anchor">#</a> Vue 3.x 响应式原理</h3> <ul><li>Vue3.x 改用 Proxy 替代 Object.defineProperty。因为 Proxy 可以直接监听对象和数组的变化，并且有多达 13 种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。</li> <li>原生 Proxy 只会代理对象的第一层，Vue3.0 为了实现了深度观测 reactive 实现深度响应式化对象属性，判断当前 Reflect.get 的返回值是否为 Object，如果是则再通过 reactive 方法继续做代理。</li> <li>监测数组的时候可能触发多次 get/set，为了防止触发多次，判断 key 是否为当前被代理对象 target 自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行 trigger。</li></ul> <h2 id="vue-的插槽理解"><a href="#vue-的插槽理解" class="header-anchor">#</a> Vue 的插槽理解</h2> <ul><li><p><a href="https://juejin.im/post/5ef6d1325188252e75366ab5#heading-1" target="_blank" rel="noopener noreferrer">来自掘金<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p>默认插槽</p> <ul><li>一居室中默认插槽摆家具</li></ul> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 组件内部 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token comment">&lt;!--这是一个一居室--&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>one-bedroom<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!--添加一个默认插槽，用户可以在外部随意定义这个一居室的内容--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 使用组件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token comment">&lt;!--这里一居室--&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>one-bedroom</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!--将家具放到房间里面，组件内部就是上面提供的默认插槽的空间--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>先放一个小床，反正没有女朋友<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>再放一个电脑桌，在家还要加班写bug<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>one-bedroom</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">import</span> OneBedroom <span class="token keyword">from</span> <span class="token string">&quot;../components/one-bedroom&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    components<span class="token operator">:</span> <span class="token punctuation">{</span>
      OneBedroom<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>具名插槽</p> <ul><li>两居室使用 name=&quot;desc&quot;进行区分两个插槽，一个不带 name 的 <code>&lt;slot&gt;</code>出口会带有隐含的名字“default”。不指定具体 name 的插槽内容将传入默认 slot 中。</li></ul> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 组件内部 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>two-bedroom<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!--这是主卧--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>master-bedroom<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
      <span class="token comment">&lt;!---主卧使用默认插槽--&gt;</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!--这是次卧--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>secondary-bedroom<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
      <span class="token comment">&lt;!--次卧使用具名插槽--&gt;</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>secondard<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 使用组件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>two-bedroom</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!--主卧使用默认插槽--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>放一个大床，要结婚了，嘿嘿嘿<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>放一个衣柜，老婆的衣服太多了<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>算了，还是放一个电脑桌吧，还要写bug<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!--次卧，通过v-slot:secondard 可以指定使用哪一个具名插槽， v-slot:secondard 也可以简写为 #secondard--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>secondard</span><span class="token punctuation">&gt;</span></span>
      <span class="token comment">&lt;!-- vue3将只支持v-slot在template传入，目前仍可用2.6.0起废弃的 slot来传入  &lt;div slot=&quot;secondard&quot;&gt; &lt;/div&gt;  --&gt;</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>父母要住，放一个硬一点的床，软床对腰不好<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>放一个衣柜<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>two-bedroom</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">import</span> TwoBedroom <span class="token keyword">from</span> <span class="token string">&quot;../components/slot/two-bedroom&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    components<span class="token operator">:</span> <span class="token punctuation">{</span>
      TwoBedroom<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>作用域插槽</p> <ul><li>组件内部向外传递参数，外部可根据参数来传入对应内容</li></ul> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 组件内部 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>two-bedroom<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!--其他内容省略--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>toilet<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
      <span class="token comment">&lt;!--通过v-bind 可以向外传递参数, 告诉外面卫生间可以放洗衣机--&gt;</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>toilet<span class="token punctuation">&quot;</span></span> <span class="token attr-name">v-bind</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{ washer: true }<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 使用组件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>two-bedroom</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!--其他省略--&gt;</span>
    <span class="token comment">&lt;!--卫生间插槽，通过v-slot=&quot;scope&quot;可以获取组件内部通过v-bind传的值--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>toilet</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>scope<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
      <span class="token comment">&lt;!--判断是否可以放洗衣机--&gt;</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>scope.washer<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>这里放洗衣机<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>two-bedroom</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>插槽的默认值</p> <ul><li>装修好的房子里已经有默认的家具，不传入插槽，则用默认的插槽内容。</li></ul> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 组件内部 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>second-hand-house<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>master-bedroom<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
      <span class="token comment">&lt;!--插槽可以指定默认值，如果外部调用组件时没有修改插槽内容，则使用默认插槽--&gt;</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>这里有一张水床，玩的够嗨<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>还有一个衣柜，有点旧了<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!--这是次卧--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>secondary-bedroom<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
      <span class="token comment">&lt;!--次卧使用具名插槽--&gt;</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>secondard<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>这里有一张婴儿床<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 使用组件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>second-hand-house</span><span class="token punctuation">&gt;</span></span>
  <span class="token comment">&lt;!--主卧使用默认插槽，只装修主卧--&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>放一个大床，要结婚了，嘿嘿嘿<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>放一个衣柜，老婆的衣服太多了<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>算了，还是放一个电脑桌吧，还要写bug<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>second-hand-house</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li></ul> <h2 id="vue-动态路由方案"><a href="#vue-动态路由方案" class="header-anchor">#</a> Vue 动态路由方案</h2> <ul><li>整体思路
<ul><li>登录：当用户填写完账号和密码后向服务端验证是否正确，验证通过之后，服务端会返回一个 token，拿到 token 之后（我会将这个 token 存贮到 cookie 中，保证刷新页面后能记住用户登录状态），前端会根据 token 再去拉取一个 user_info 的接口来获取用户的详细信息（如用户权限，用户名等等信息）</li> <li>权限验证：通过 token 获取用户对应的 role，动态根据用户的 role 算出其对应有权限的路由，通过 router.addRoutes 动态挂载这些路由。
<ul><li>设置一个 tree 空间给每个页面动态配置权限，将这份路由表保存到后端</li> <li>当用户登录后得到 roles，前端根据 roles 去向后端请求可访问的路由表，</li> <li>之后就是 router.addRoutes 动态挂载到 router 上</li></ul></li></ul></li> <li>具体实现
<ul><li>router 里实例化不需要权限的公用页面</li> <li>设置一个 tree 空间给每个页面动态配置权限，通过 meta 标签来标示改页面能访问的权限，<code>meta: { role: ['admin','super_editor'] }</code>，将这份路由表保存到后端</li> <li>在路由钩子 router.beforeEach 里判断是否有 token，没有则去登录页</li> <li>有 token 则获取用户信息比如 roles，拿到权限路由表</li> <li>通过用户的权限和我们配置的每一个页面所需要的权限做匹配，最后返回一个该用户能够访问路由有哪些，</li> <li>通过 addRoutes 将可访问路由，动态添加到路由表里，没权限的默认去 404 页</li></ul></li></ul> <h2 id="weex-架构-✨"><a href="#weex-架构-✨" class="header-anchor">#</a> weex 架构 ✨</h2> <ul><li>早期混合开发：
<ul><li>使用客户端内置浏览器也就是 webview，前端开发的是 H5 页面。</li> <li>优点：提高开发效率，满足跨平台需求</li> <li>缺点：性能较差</li></ul></li> <li>weex
<ul><li>阿里和 vue 合作的性能更好的跨端解决方案，利用 JS 引擎实现了<strong>跨平台能力</strong>，同时又将 JS 控件，对应解析为原生控件进行渲染，实现了<strong>性能的提升</strong>。</li> <li>流程：
<ul><li>vue 代码打包成 JS 文件，APP 请求服务器拉取这些 JS 文件，然后进入 APP 处理</li> <li>APP: 四个重要组成部分 JS runtime、JS bridge、native render、weex core
<ul><li><code>JS runtime</code>: 执行 JS 代码，iOS 使用 JS Core，安卓上使用 V8</li> <li><code>weex core</code>: weex 的核心代码，负责 JS 解析工作，构建虚拟 DOM，根据 diff 将修改 patch 到视图上。</li> <li><code>JS bridge</code>: 翻译成原生 native 可执行的代码</li> <li><code>native render</code>:负责视图渲染，渲染器收到指令后，渲染为原生组件，我们写的<code>&lt;div&gt;&lt;p&gt;</code>等标签，对应变成客户端的原生组件，展示给用户。</li></ul></li></ul></li> <li>优点：跨平台，体验流畅</li> <li>缺点：框架和平台耦合过多，版本兼容维护比较困难。性能有瓶颈，因为 JS bridge 也存在性能限制。</li> <li>架构图
<img src="/assets/img/frame-weex.2aba215a.jpg" alt="frame-weex"></li></ul></li></ul> <h2 id="其他"><a href="#其他" class="header-anchor">#</a> 其他</h2> <h3 id="v-bind"><a href="#v-bind" class="header-anchor">#</a> v-bind</h3> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 绑定一个 attribute --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>imageSrc<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token comment">&lt;!-- 缩写 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">:src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>imageSrc<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>

<span class="token comment">&lt;!-- 绑定一个全是 attribute 的对象 --&gt;</span>
<span class="token comment">&lt;!-- 字段的props透传至element-ui用到此方法 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>el-button</span> <span class="token attr-name">v-bind</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{ type: <span class="token punctuation">'</span>danger<span class="token punctuation">'</span>, size: <span class="token punctuation">'</span>mini<span class="token punctuation">'</span> }<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>el-button</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 等同于 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>el-button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>danger<span class="token punctuation">&quot;</span></span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>mini<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>主要按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>el-button</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/pages/folder1/frame-common.html" class="prev">
        框架通识
      </a></span> <span class="next"><a href="/pages/folder1/react.html">
        框架-React
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d50c72b0.js" defer></script><script src="/assets/js/2.7285e602.js" defer></script><script src="/assets/js/10.95e645d2.js" defer></script>
  </body>
</html>
