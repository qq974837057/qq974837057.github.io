<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>时间复杂度和空间复杂度 | 元气Blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/wind.png">
    <meta name="description" content="元气Joe的前端世界">
    
    <link rel="preload" href="/assets/css/0.styles.8a46e3d7.css" as="style"><link rel="preload" href="/assets/js/app.d50c72b0.js" as="script"><link rel="preload" href="/assets/js/2.7285e602.js" as="script"><link rel="preload" href="/assets/js/4.2ab80d3e.js" as="script"><link rel="prefetch" href="/assets/js/10.95e645d2.js"><link rel="prefetch" href="/assets/js/11.7a5bbaab.js"><link rel="prefetch" href="/assets/js/12.0bd756fe.js"><link rel="prefetch" href="/assets/js/13.c032609a.js"><link rel="prefetch" href="/assets/js/14.621e82f0.js"><link rel="prefetch" href="/assets/js/15.2bc7bb03.js"><link rel="prefetch" href="/assets/js/16.7b7424df.js"><link rel="prefetch" href="/assets/js/17.9a2f808e.js"><link rel="prefetch" href="/assets/js/18.2bb036cb.js"><link rel="prefetch" href="/assets/js/19.d8537971.js"><link rel="prefetch" href="/assets/js/20.c8e9e8fe.js"><link rel="prefetch" href="/assets/js/21.efec8fa1.js"><link rel="prefetch" href="/assets/js/22.3385e6bf.js"><link rel="prefetch" href="/assets/js/23.a260f1cf.js"><link rel="prefetch" href="/assets/js/24.69037aca.js"><link rel="prefetch" href="/assets/js/25.ebc4667f.js"><link rel="prefetch" href="/assets/js/26.d355b386.js"><link rel="prefetch" href="/assets/js/27.8c327e12.js"><link rel="prefetch" href="/assets/js/28.98128502.js"><link rel="prefetch" href="/assets/js/29.b35b9692.js"><link rel="prefetch" href="/assets/js/3.efa71162.js"><link rel="prefetch" href="/assets/js/30.d28a8fd7.js"><link rel="prefetch" href="/assets/js/31.2eab1cab.js"><link rel="prefetch" href="/assets/js/32.0acbefde.js"><link rel="prefetch" href="/assets/js/33.35108fd8.js"><link rel="prefetch" href="/assets/js/34.bd1353df.js"><link rel="prefetch" href="/assets/js/5.b6c9c262.js"><link rel="prefetch" href="/assets/js/6.d1cbcbdc.js"><link rel="prefetch" href="/assets/js/7.7f87f0fb.js"><link rel="prefetch" href="/assets/js/8.97df5136.js"><link rel="prefetch" href="/assets/js/9.80311f25.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8a46e3d7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/wind.png" alt="元气Blog" class="logo"> <span class="site-name can-hide">元气Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分类" class="dropdown-title"><span class="title">分类</span> <span class="arrow down"></span></button> <button type="button" aria-label="分类" class="mobile-dropdown-title"><span class="title">分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/folder1/html.html" class="nav-link">
  文章
</a></li><li class="dropdown-item"><!----> <a href="/pages/folder2/test4.html" class="nav-link">
  随笔
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/qq974837057" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分类" class="dropdown-title"><span class="title">分类</span> <span class="arrow down"></span></button> <button type="button" aria-label="分类" class="mobile-dropdown-title"><span class="title">分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/folder1/html.html" class="nav-link">
  文章
</a></li><li class="dropdown-item"><!----> <a href="/pages/folder2/test4.html" class="nav-link">
  随笔
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/qq974837057" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/folder1/html.html" class="sidebar-link">HTML</a></li><li><a href="/pages/folder1/css.html" class="sidebar-link">CSS</a></li><li><a href="/pages/folder1/js.html" class="sidebar-link">JS</a></li><li><a href="/pages/folder1/ts.html" class="sidebar-link">TS</a></li><li><a href="/pages/folder1/browser.html" class="sidebar-link">HTTP与浏览器</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端进阶</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/folder1/security.html" class="sidebar-link">前端安全</a></li><li><a href="/pages/folder1/monitor.html" class="sidebar-link">监控体系</a></li><li><a href="/pages/folder1/performance.html" class="sidebar-link">性能优化</a></li><li><a href="/pages/folder1/design-pattern.html" class="sidebar-link">设计模式和架构</a></li><li><a href="/pages/folder1/refactor.html" class="sidebar-link">代码重构之道</a></li><li><a href="/pages/folder1/nodejs.html" class="sidebar-link">node与前沿</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/folder1/frame-common.html" class="sidebar-link">框架通识</a></li><li><a href="/pages/folder1/frame.html" class="sidebar-link">框架-Vue</a></li><li><a href="/pages/folder1/react.html" class="sidebar-link">框架-React</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>工程化和协作</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/folder1/webpack.html" class="sidebar-link">Webpack</a></li><li><a href="/pages/folder1/normalize.html" class="sidebar-link">前端规范</a></li><li><a href="/pages/folder1/git.html" class="sidebar-link">Git</a></li><li><a href="/pages/folder1/build.html" class="sidebar-link">构建</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>算法与编程</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/folder1/algorithm-data.html" aria-current="page" class="active sidebar-link">数据结构和算法-概念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#时间复杂度和空间复杂度" class="sidebar-link">时间复杂度和空间复杂度</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#时间空间的选择" class="sidebar-link">时间空间的选择</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#线性表-or-非线性表" class="sidebar-link">线性表 or 非线性表</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#数组" class="sidebar-link">数组</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#特点" class="sidebar-link">特点</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#数组和链表" class="sidebar-link">数组和链表</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#链表" class="sidebar-link">链表</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#特点-2" class="sidebar-link">特点</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#分类" class="sidebar-link">分类</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#技巧" class="sidebar-link">技巧</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#堆栈" class="sidebar-link">堆栈</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#队列" class="sidebar-link">队列</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#散列表-hash-table" class="sidebar-link">散列表 Hash Table</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#二叉树" class="sidebar-link">二叉树</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#树的概念" class="sidebar-link">树的概念</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#二叉树的遍历" class="sidebar-link">二叉树的遍历</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#二叉搜索-查找-树-binary-search-tree" class="sidebar-link">二叉搜索（查找）树 - Binary Search Tree</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#堆" class="sidebar-link">堆</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#递归" class="sidebar-link">递归</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#排序" class="sidebar-link">排序</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#二分查找" class="sidebar-link">二分查找</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#广度优先搜索bfs" class="sidebar-link">广度优先搜索BFS</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#深度优先搜索dfs" class="sidebar-link">深度优先搜索DFS</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#动态规划" class="sidebar-link">动态规划</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#贪心算法" class="sidebar-link">贪心算法</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#回溯算法" class="sidebar-link">回溯算法</a></li><li class="sidebar-sub-header"><a href="/pages/folder1/algorithm-data.html#分治算法" class="sidebar-link">分治算法</a></li></ul></li><li><a href="/pages/folder1/algorithm-sort.html" class="sidebar-link">数据结构和算法-排序专题</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="时间复杂度和空间复杂度"><a href="#时间复杂度和空间复杂度" class="header-anchor">#</a> 时间复杂度和空间复杂度</h2> <p><img src="/assets/img/algo-concept.af92f97c.jpg" alt="复杂度概念"> <img src="/assets/img/algo-curve.80e2d6ac.png" alt="复杂度曲线"> <img src="/assets/img/algo-data.abaaad90.png" alt="常用结构复杂度"></p> <h3 id="时间空间的选择"><a href="#时间空间的选择" class="header-anchor">#</a> 时间空间的选择</h3> <ul><li>用时间换空间：内存紧缺情况下，选择空间复杂度低，时间复杂度高的。</li> <li>用空间换时间：空间充足、追求执行速度情况下，选择空间复杂度高，时间复杂度低的。</li></ul> <h3 id="线性表-or-非线性表"><a href="#线性表-or-非线性表" class="header-anchor">#</a> 线性表 or 非线性表</h3> <ul><li>线性表：数组、链表、队列、栈</li> <li>非线性表：二叉树、堆、图等</li></ul> <h2 id="数组"><a href="#数组" class="header-anchor">#</a> 数组</h2> <h3 id="特点"><a href="#特点" class="header-anchor">#</a> 特点</h3> <ul><li>1、属于线性表,只有前后两个方向</li> <li>2、一组连续的内存空间</li> <li>3、随机访问高效，根据下标随机访问的时间复杂度为O(1)，公式计算该存储的地址。</li> <li>4、插入和删除是低效的，插入第k个位置需要将k~n的元素都往后移动，删除第k个元素同样也要移动元素(特殊情况是比较快，比如添加/删除最后一个元素)。但平均时间复杂度为O(n)</li></ul> <h3 id="数组和链表"><a href="#数组和链表" class="header-anchor">#</a> 数组和链表</h3> <p>数组：【随机读取快速】【插入/删除需要移动其他成员】【场景：随机根据index读取元素】
链表：【随机读取低效】【插入/删除只需改变指针】【场景：模拟流程、可中断、可继续】</p> <h2 id="链表"><a href="#链表" class="header-anchor">#</a> 链表</h2> <h3 id="特点-2"><a href="#特点-2" class="header-anchor">#</a> 特点</h3> <ul><li>1、属于线性表,只有前后两个方向，头结点（第一个）记录链表的基地址，尾结点（最后一个）的next指针指向NULL</li> <li>2、由零散的内存块串联</li> <li>3、随机访问低效，根据下标随机访问的时间复杂度为O(n)，得从第一个往后查找。</li> <li>4、插入和删除是高效的，本身是不连续的内存空间，可以直接改变相邻结点的指针即可。时间复杂度为O(1），双向链表还会更高效，适合更多情况。</li></ul> <h3 id="分类"><a href="#分类" class="header-anchor">#</a> 分类</h3> <ul><li>单链表：尾结点指针指向空地址</li> <li>循环链表：尾结点指针指向链表的头结点，首尾相连</li> <li>双链表：有两个方向，有next后指针和prev前指针，占用更多内存空间。某些情况插入、删除比单链表更高效。如：删除给定指针指向的结点，需要找到前结点。此时双向链表复杂度为O(1)，单链表还要从头遍历查找为O(n)。</li> <li>双向循环链表：前两个结合。</li></ul> <h3 id="技巧"><a href="#技巧" class="header-anchor">#</a> 技巧</h3> <p>1、理解：指针其实就是引用，指针中保存变量的内存地址，指向该变量，可通过指针找到变量。
2、注意：指针丢失和内存泄漏（比如注意插入的操作顺序，先将新节点的next指向前个节点的next，再将前个节点的next指向新节点。）</p> <div class="language-js extra-class"><pre class="language-js"><code>x<span class="token operator">-</span><span class="token operator">&gt;</span>next <span class="token operator">=</span> p<span class="token operator">-</span><span class="token operator">&gt;</span>next<span class="token punctuation">;</span> <span class="token comment">// 将x的结点的next指针指向b结点；</span>
p<span class="token operator">-</span><span class="token operator">&gt;</span>next <span class="token operator">=</span> x<span class="token punctuation">;</span>       <span class="token comment">// 将p的next指针指向x结点；</span>
</code></pre></div><p>3、使用哨兵解决边界问题，针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。为了简化，使用带头链表（head指针指向哨兵节点）
4、考虑边界：
如果链表为空时，代码是否能正常工作？
如果链表只包含一个结点时，代码是否能正常工作？
如果链表只包含两个结点时，代码是否能正常工作？
代码逻辑在处理头结点和尾结点的时候，是否能正常工作？
5、使用画图法让思路清晰
6、多练，常用链表操作</p> <ul><li>单链表反转：迭代；递归</li> <li>链表中是否有环：哈希表保存，看是否访问过；快慢指针（慢1块2）；</li> <li>两个有序的链表合并</li> <li>删除链表倒数第 n 个结点</li> <li>求链表的中间结点</li></ul> <h2 id="堆栈"><a href="#堆栈" class="header-anchor">#</a> 堆栈</h2> <p><img src="/assets/img/algo-stack.d42f028f.jpg" alt="堆栈"></p> <ul><li>如何实现栈：
<ul><li>可基于数组（顺序栈）</li> <li>或基于链表（链式栈）</li></ul></li> <li>复杂度：
<ul><li>访问和查找时间复杂度为O(n)</li> <li>入栈和出栈时间/空间复杂度都是O(1)</li> <li>入栈、出栈只涉及栈顶个别数据的操作，所以时间复杂度都是 O(1)。</li> <li>一两个临时变量存储空间，所以空间复杂度是 O(1)。</li></ul></li> <li>场景应用：
<ul><li>函数调用栈</li> <li>表达式运算（两个栈实现，一个放操作数，一个放运算符）</li> <li>判断括号嵌套匹配是否正确（遍历将左括号压入，遇到右括号取出）</li> <li>浏览器前进后退（两个栈实现，后退则压入另一个栈，前进从栈取出）</li></ul></li></ul> <h2 id="队列"><a href="#队列" class="header-anchor">#</a> 队列</h2> <p><img src="/assets/img/algo-queue.cd074708.jpg" alt="队列"></p> <ul><li>场景：
<ul><li>线程池的请求排队，先进先服务，资源有限的场景，没有空闲资源，可通过队列这种数据结构实现请求排队。</li></ul></li> <li>操作：
<ul><li>入队：enqueue()</li> <li>出队：dequeue()</li></ul></li> <li>复杂度：
<ul><li>访问和查找时间复杂度为O(n)</li> <li>插入和删除时间/空间复杂度都是O(1)</li></ul></li> <li>实现
<ul><li>数组实现：顺序队列，两个指针，一个head指向对头，一个tail指向 队尾，出队head和入队的tail指针都会持续向后移动，当空间用满之后，需要做数据搬移，在入队时候进行一次搬移，将剩下的任务搬到下标为0的位置。</li> <li>链表实现：链式队列</li></ul></li> <li>循环队列：
<ul><li>tail指针循环回到头部位置0的下标，而不是加1，解决数据搬移问题，需要做好队空和队满的判断。</li></ul></li></ul> <h2 id="散列表-hash-table"><a href="#散列表-hash-table" class="header-anchor">#</a> 散列表 Hash Table</h2> <blockquote><p>了解其原理即可，一般都有较好的封装实现</p></blockquote> <ul><li>散列表也叫哈希表，本质是数组的一种扩展，利用数组支持按照下标随机访问数据的特性。</li> <li>通过散列函数将元素的键  &gt; 映射为下标，将数据存入该下标的位置。</li> <li>在查询元素时，通过散列将键转为下标即可用O(1)的时间找到该key对应在数组中的数据。</li> <li>组成：
<ul><li>key 键</li> <li>hash function 哈希函数（散列函数）</li> <li>hash(key)  哈希值，是由key通过hash function计算得到的，映射为数组的下标
<img src="/assets/img/Hash-1.3d93daea.png" alt="Hash-1"></li></ul></li> <li>解决散列冲突：
<ul><li>开放寻址法</li> <li>链表法（简单）
<ul><li>在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</li> <li>当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)。.</li> <li>当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。时间复杂度跟链表的长度 k 成正比，也就是 O(k)。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。
<img src="/assets/img/Hash-2.155e5824.png" alt="Hash-2"></li></ul></li></ul></li> <li>散列和链表的结合使用
<ul><li>散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历。</li> <li>因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。为了解决这个问题，我们将散列表和链表（或者跳表）结合在一起使用。</li></ul></li> <li>例子：LRU 缓存淘汰算法
<ul><li>查找操作，删除头结点、链表尾部插入数据等，都可以在 O(1) 的时间复杂度内完成。所以，这三个操作的时间复杂度都是 O(1)。</li> <li>通过散列表和双向链表的组合使用，实现了一个高效的、支持 LRU 缓存淘汰算法的缓存系统原型。<br> <img src="/assets/img/Hash-3.4028f9d1.png" alt="Hash-3"></li></ul></li></ul> <h2 id="二叉树"><a href="#二叉树" class="header-anchor">#</a> 二叉树</h2> <h3 id="树的概念"><a href="#树的概念" class="header-anchor">#</a> 树的概念</h3> <ul><li>节点：树中的每个元素称为节点，二叉树的节点数最多为2^k - 1(k为二叉树有多少层)，在非空二叉树中，第i层的结点总数不超过2^(i-1)</li> <li>根节点:没有父节点的节点</li> <li>父节点:指向子节点的节点</li> <li>子节点:被父节点指向的节点</li> <li>兄弟节点:具有相同父节点的多个节点称为兄弟节点关系</li> <li>叶子节点：没有子节点的节点</li></ul> <hr> <ul><li>节点的高度：节点到叶子节点的最长路径(边数)</li> <li>节点的深度：根节点到节点的路径所包含的边数（根节点的深度是0）</li> <li>节点的层数：节点的深度+1（根节点的层数是1）</li> <li>树的高度：等于根节点的高度
<img src="/assets/img/B-Tree-height.42cd56d0.png" alt="高度深度"></li></ul> <hr> <ul><li>二叉树：每个节点最多两个叉，也就是两个子节点。</li> <li>完全二叉树：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，也就是铺满完整。</li> <li>满二叉树：满二叉树又是完全二叉树的一种特殊情况。叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点。
<img src="/assets/img/B-Tree-full.31ff7f1b.png" alt="满二叉树"></li></ul> <hr> <p>两种存储方式：</p> <ul><li>链式存储法:每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。</li> <li>基于数组的顺序存储法：根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，串起整棵树。</li></ul> <h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="header-anchor">#</a> 二叉树的遍历</h3> <p><img src="/assets/img/B-Tree-traverse.6cac6f7e.png" alt="二叉树的遍历"></p> <h4 id="前序遍历-根左右"><a href="#前序遍历-根左右" class="header-anchor">#</a> 前序遍历（根左右）</h4> <blockquote><p>对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</p></blockquote> <h4 id="中序遍历-左根右"><a href="#中序遍历-左根右" class="header-anchor">#</a> 中序遍历（左根右）</h4> <blockquote><p>对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</p></blockquote> <h4 id="后序遍历-左右根"><a href="#后序遍历-左右根" class="header-anchor">#</a> 后序遍历（左右根）</h4> <blockquote><p>对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</p></blockquote> <h3 id="二叉搜索-查找-树-binary-search-tree"><a href="#二叉搜索-查找-树-binary-search-tree" class="header-anchor">#</a> 二叉搜索（查找）树 - Binary Search Tree</h3> <blockquote><p>有序的、左子树的所有值都小于根节点、右子树的值都大于根节点，或者空节点也是合理的查找树。</p></blockquote> <ul><li>支持动态数据集合的快速插入、删除、查找操作。</li> <li>搜索更快速，平均O(logn)，最坏O(n)。
<img src="/assets/img/B-Tree-search.5d3ede28.png" alt="二叉搜索树"></li></ul> <h2 id="堆"><a href="#堆" class="header-anchor">#</a> 堆</h2> <ul><li><p>概念：一种特殊的树</p></li> <li><p>需要满足：完全二叉树、每个节点的值都大于等于或小于等于它的左右子节点的值</p></li> <li><p>分类</p> <ul><li>大顶堆：每个节点的值都大于等于子树中每个节点值</li> <li>小顶堆：每个节点的值都小于等于子树中每个节点值</li></ul></li> <li><p>存储：使用数组结构来存储，节省空间</p></li> <li><p>核心操作：堆中插入元素、删除堆顶元素</p></li> <li><p>插入一个元素：复杂度O(logn)</p> <ul><li>堆化：调整交换元素的位置，使其满足堆的特性（大于等于或者小于等于）</li> <li>插在最后叶子节点，与父节点对比大小，不满足则互换节点，从下往上堆化，直到满足条件为止。
<img src="/assets/img/heap-1.fa07fb7a.png" alt="插入一个元素"></li></ul></li> <li><p>删除堆顶元素：复杂度O(logn)</p> <ul><li>根据关系：堆顶要么是最大值（大顶堆），要么是最小值（小顶堆）</li> <li>删除堆顶元素后，将最后一个节点放到堆顶，从上往下堆化，这样就可以满足堆的结构
<img src="/assets/img/heap-2.01a13bd7.png" alt="删除堆顶元素"></li></ul></li> <li><p>重要应用</p> <ul><li>堆排序</li> <li>Top K 问题：堆化，取前 K 个元素</li> <li>中位数问题：维护两个堆，一大（前50%）一小（后50%），奇数元素取大顶堆的堆顶，偶数取取大、小顶堆的堆顶</li></ul></li> <li><p>Top K问题【求(第/前)K大用小顶堆，求(第/前)K小用大顶堆】</p> <ul><li>第一类：静态数据集合的Top K，数据集合不会变动。
<ul><li>维护一个大小为K的小顶堆，顺序遍历数组集合，将数组遍历的元素与堆顶元素比较。</li> <li>数组元素大于堆顶元素，将堆顶元素删除，将这个元素插入堆中，并进行堆化。</li> <li>数组元素小于堆顶元素，不作处理，继续遍历数组。</li> <li>全部遍历完成，堆中的数据就是前K大的数据。</li> <li>遍历数组需要 O(n) 的时间复杂度，一次堆化需要 O(logK) 时间复杂度，所以时间复杂度O(n logK)。空间复杂度O(k)，用于存储堆元素。</li> <li>其他做法：利用排序来做，将数组进行排序，然后取K个数即可，时间复杂度O(n log n)</li></ul></li> <li>第二类：动态数据集合的Top K，有数据会动态添加到集合中。
<ul><li>一直维护K大小的小顶堆，每次有数据添加到集合，就将它与堆顶元素比较。</li> <li>任何时候查询前K大的数据，都可以立刻返回。每次求 Top K 问题的时间复杂度仅为 O(logK)。</li></ul></li></ul></li> <li><p>求中位数</p></li></ul> <blockquote><p>求中位数，对于静态数据，中位数是固定的，可采用先排序，后取中间值。</p></blockquote> <blockquote><p>对于动态数据，中位数是不固定的，每次插入数据后，都需要排序，会变得很低效，所以可以采用两个堆的方法实现高效求中位数。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>中位数，就是处于中间的那个数：
[1, 2, 3, 4, 5]    的中位数是 3
[1, 2, 3, 4, 5, 6]   的中位数是 3, 4
即：
当 n % 2 !== 0 时，中位数为：arr[(n-1)/2]
当 n % 2 === 0 时，中位数为：arr[n/2],  arr[n/2 + 1]
</code></pre></div><ul><li><p>利用两个堆来求解中位数问题</p></li> <li><p>大顶堆：用来存取前 n/2 个小元素，如果 n 为奇数，则用来存取前 Math.floor(n/2) + 1 个元素</p></li> <li><p>小顶堆：用来存取后 n/2 个小元素</p></li> <li><p>那么，中位数就为：</p> <ul><li>n 为奇数：中位数是大顶堆的堆顶元素</li> <li>n 为偶数：中位数是大顶堆的堆顶元素与小顶堆的堆顶元素
<img src="/assets/img/heap-3.63b45c5f.jpg" alt="中位数1"></li></ul></li> <li><p>当数组为动态数组时，每当数组中插入一个元素时，需要调整堆</p></li> <li><p>如果插入元素比大顶堆的堆顶要大，则将该元素插入到小顶堆中；如果要小，则插入到大顶堆中。</p></li> <li><p>当插入完后，如果大顶堆、小顶堆中元素的个数不满足我们已上的要求，我们就需要不断的将大顶堆的堆顶元素或小顶堆的堆顶元素移动到另一个堆中，直到满足要求</p></li> <li><p>由于插入元素到堆、移动堆顶元素都需要堆化，所以，插入的时间复杂度为 O(logN) ，每次插入完成后求中位数仅仅需要返回堆顶元素即可，时间复杂度为 O(1)</p></li></ul> <p><img src="/assets/img/heap-4.813884f7.jpg" alt="中位数2"></p> <h2 id="递归"><a href="#递归" class="header-anchor">#</a> 递归</h2> <ul><li>优缺点：（需要根据实际情况选择是否用递归解决问题）
<ul><li>优点：代码简洁，表达能力强</li> <li>缺点：重复计算，过多调用导致时间空间复杂度高。</li></ul></li> <li>递归需要满足三个条件：
<ul><li>一个问题的解可分解为子问题的解</li> <li>数据规模不同，但思路相同</li> <li>存在终止条件</li></ul></li> <li>如何编写：
<ul><li>写出递推公式</li> <li>找到终止条件</li> <li>思路：大问题分解小问题，写出递推公式，推敲终止条件，翻译为代码。</li> <li>注意：不需要想一层层的调用关系，只需要抽象成一个公式即可。</li></ul></li> <li>控制副作用：
<ul><li>避免堆栈溢出（设置调用深度，超出则报错）</li> <li>避免重复计算（通过数据结构如散列表，保存计算过的值）</li></ul></li> <li>应用：
<ul><li>DFS 深度优先搜索</li> <li>前中后序二叉树遍历</li> <li>分治算法（中间值有重复计算，效果需优化）</li></ul></li></ul> <h2 id="排序"><a href="#排序" class="header-anchor">#</a> 排序</h2> <blockquote><p>详见排序专题</p></blockquote> <h2 id="二分查找"><a href="#二分查找" class="header-anchor">#</a> 二分查找</h2> <p><img src="/assets/img/DFS-BFS.aaa0aafd.png" alt="BFS和DFS"></p> <blockquote><p>BFS和DFS两种搜索算法仅适用于树或者图不大的搜索。
树的节点搜索不会重复，图就可能会出现重复，要进行判断是否已经出现过，可使用set结构保存已经出现过的。</p></blockquote> <h2 id="广度优先搜索bfs"><a href="#广度优先搜索bfs" class="header-anchor">#</a> 广度优先搜索BFS</h2> <ul><li>一般使用队列实现</li> <li>从起始顶点开始，一层一层往外遍历</li> <li>它的特点是越是接近根结点的结点将越早地遍历</li> <li>题目：二叉树的层次遍历
<img src="/assets/img/BFS.6fe1bfc2.jpg" alt="BFS"></li></ul> <h2 id="深度优先搜索dfs"><a href="#深度优先搜索dfs" class="header-anchor">#</a> 深度优先搜索DFS</h2> <ul><li>一般使用栈实现</li> <li>回溯思想，先一杆子叉到底，回头看看有没有漏网之鱼</li> <li>解题推荐递归写法</li> <li>题目：二叉树的最大深度
<img src="/assets/img/DFS.7a5c50dd.png" alt="DFS"></li></ul> <h2 id="动态规划"><a href="#动态规划" class="header-anchor">#</a> 动态规划</h2> <ul><li>1、解法：先 （递归+记忆化） -&gt; 再转为 递推</li> <li>2、状态定义：dp[n], fib[n]</li> <li>3、状态转移DP方程：dp[n] = best_of(dp[n - 1],dp[n-2],...)</li> <li>4、存在最优子结构（也就是每个子问题都可得到最优解）</li> <li>5、只关心前个阶段的状态值，不关系如何一步一步推导；某阶段状态一旦确定，就不受之后阶段的决策影响</li> <li>特点：适合求极大/小值，记录局部最优值，避免重复计算，通过动态转移方程，推导出最后的答案。</li></ul> <h2 id="贪心算法"><a href="#贪心算法" class="header-anchor">#</a> 贪心算法</h2> <ul><li><p>求解时，总是做出在当前看来是最好的选择</p></li> <li><p>比较少见，因为处处贪心，大部分情况下，结果并不会最优。</p></li> <li><p>贪心解决不了就使用动态规划。</p></li> <li><p>适合：问题能分解为子问题，子问题的最优解能推到最后最终问题的最优解。</p></li> <li><p>贪心算法和动态规划区别是：</p> <ul><li>贪心每个子问题都会做一个当前最优的选择，不能回退。</li> <li>而动态规划可以保存之前的计算结果，根据以前结果来选择，可以回退。</li> <li>是动态规划的一种特殊情况，条件限制比较多。</li></ul></li></ul> <h2 id="回溯算法"><a href="#回溯算法" class="header-anchor">#</a> 回溯算法</h2> <ul><li><p>类似枚举所有解，找到当前阶段满足期望的解。</p></li> <li><p>在每个阶段遇到分叉口时，随便选一条</p></li> <li><p>当走不同（不符合期望的解），就回退到分叉口，另选别的解。</p></li> <li><p>实现方式：递归，可用剪枝操作提高效率，如果能够提前知道这一条分支不能搜索到满意的结果，就可以提前结束。</p></li> <li><p>特点：不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，穷举整棵决策树是无法避免的。复杂度一般都很高是指数级别，只适合小规模数据。能用动态、贪心解决都可以用回溯。</p></li> <li><p>应用：全排列、深度优先搜索、八皇后、背包问题。</p></li> <li><p>和深度优先搜索区别：</p> <ul><li>深度优先是“遍历”，本质是无序的。</li> <li>回溯是“求解”，本质是有序的。</li></ul></li> <li><p>解题框架</p> <div class="language-js extra-class"><pre class="language-js"><code>res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token keyword">function</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token parameter">路径</span><span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token keyword">if</span> 满足结束条件<span class="token operator">:</span>
        res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>路径的拷贝<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    
    <span class="token keyword">for</span> 循环在选择列表中选择元素<span class="token operator">:</span>
        做选择
        <span class="token function">backtrack</span><span class="token punctuation">(</span>路径<span class="token punctuation">)</span> <span class="token comment">// 递归,调用自己</span>
        撤销选择

<span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">return</span> res        
</code></pre></div></li></ul> <h2 id="分治算法"><a href="#分治算法" class="header-anchor">#</a> 分治算法</h2> <ul><li><p>分解：原问题分解为一系列子问题</p></li> <li><p>解决：递归求解每个子问题</p></li> <li><p>合并：子问题的结果合并为原问题。</p></li> <li><p>实现方式：递归</p></li> <li><p>和DP动态规划的区别：</p> <ul><li>1、分治是自顶向下，动态规划是自底向上，这里指递归树。</li> <li>2、它大部分不能抽象成多阶段决策模型。</li></ul></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/pages/folder1/build.html" class="prev">
        构建
      </a></span> <span class="next"><a href="/pages/folder1/algorithm-sort.html">
        数据结构和算法-排序专题
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d50c72b0.js" defer></script><script src="/assets/js/2.7285e602.js" defer></script><script src="/assets/js/4.2ab80d3e.js" defer></script>
  </body>
</html>
