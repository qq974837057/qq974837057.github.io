<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>链表 | 元气Blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/wind.png">
    <meta name="description" content="元气Joe的前端世界">
    
    <link rel="preload" href="/assets/css/0.styles.8a46e3d7.css" as="style"><link rel="preload" href="/assets/js/app.d50c72b0.js" as="script"><link rel="preload" href="/assets/js/2.7285e602.js" as="script"><link rel="preload" href="/assets/js/11.7a5bbaab.js" as="script"><link rel="prefetch" href="/assets/js/10.95e645d2.js"><link rel="prefetch" href="/assets/js/12.0bd756fe.js"><link rel="prefetch" href="/assets/js/13.c032609a.js"><link rel="prefetch" href="/assets/js/14.621e82f0.js"><link rel="prefetch" href="/assets/js/15.2bc7bb03.js"><link rel="prefetch" href="/assets/js/16.7b7424df.js"><link rel="prefetch" href="/assets/js/17.9a2f808e.js"><link rel="prefetch" href="/assets/js/18.2bb036cb.js"><link rel="prefetch" href="/assets/js/19.d8537971.js"><link rel="prefetch" href="/assets/js/20.c8e9e8fe.js"><link rel="prefetch" href="/assets/js/21.efec8fa1.js"><link rel="prefetch" href="/assets/js/22.3385e6bf.js"><link rel="prefetch" href="/assets/js/23.a260f1cf.js"><link rel="prefetch" href="/assets/js/24.69037aca.js"><link rel="prefetch" href="/assets/js/25.ebc4667f.js"><link rel="prefetch" href="/assets/js/26.d355b386.js"><link rel="prefetch" href="/assets/js/27.8c327e12.js"><link rel="prefetch" href="/assets/js/28.98128502.js"><link rel="prefetch" href="/assets/js/29.b35b9692.js"><link rel="prefetch" href="/assets/js/3.efa71162.js"><link rel="prefetch" href="/assets/js/30.d28a8fd7.js"><link rel="prefetch" href="/assets/js/31.2eab1cab.js"><link rel="prefetch" href="/assets/js/32.0acbefde.js"><link rel="prefetch" href="/assets/js/33.35108fd8.js"><link rel="prefetch" href="/assets/js/34.bd1353df.js"><link rel="prefetch" href="/assets/js/4.2ab80d3e.js"><link rel="prefetch" href="/assets/js/5.b6c9c262.js"><link rel="prefetch" href="/assets/js/6.d1cbcbdc.js"><link rel="prefetch" href="/assets/js/7.7f87f0fb.js"><link rel="prefetch" href="/assets/js/8.97df5136.js"><link rel="prefetch" href="/assets/js/9.80311f25.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8a46e3d7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/wind.png" alt="元气Blog" class="logo"> <span class="site-name can-hide">元气Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分类" class="dropdown-title"><span class="title">分类</span> <span class="arrow down"></span></button> <button type="button" aria-label="分类" class="mobile-dropdown-title"><span class="title">分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/folder1/html.html" class="nav-link">
  文章
</a></li><li class="dropdown-item"><!----> <a href="/pages/folder2/test4.html" class="nav-link">
  随笔
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/qq974837057" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分类" class="dropdown-title"><span class="title">分类</span> <span class="arrow down"></span></button> <button type="button" aria-label="分类" class="mobile-dropdown-title"><span class="title">分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/folder1/html.html" class="nav-link">
  文章
</a></li><li class="dropdown-item"><!----> <a href="/pages/folder2/test4.html" class="nav-link">
  随笔
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/qq974837057" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>前端基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/folder1/html.html" class="sidebar-link">HTML</a></li><li><a href="/pages/folder1/css.html" class="sidebar-link">CSS</a></li><li><a href="/pages/folder1/js.html" class="sidebar-link">JS</a></li><li><a href="/pages/folder1/ts.html" class="sidebar-link">TS</a></li><li><a href="/pages/folder1/browser.html" class="sidebar-link">HTTP与浏览器</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端进阶</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/folder1/security.html" class="sidebar-link">前端安全</a></li><li><a href="/pages/folder1/monitor.html" class="sidebar-link">监控体系</a></li><li><a href="/pages/folder1/performance.html" class="sidebar-link">性能优化</a></li><li><a href="/pages/folder1/design-pattern.html" class="sidebar-link">设计模式和架构</a></li><li><a href="/pages/folder1/refactor.html" class="sidebar-link">代码重构之道</a></li><li><a href="/pages/folder1/nodejs.html" class="sidebar-link">node与前沿</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/folder1/frame-common.html" class="sidebar-link">框架通识</a></li><li><a href="/pages/folder1/frame.html" class="sidebar-link">框架-Vue</a></li><li><a href="/pages/folder1/react.html" class="sidebar-link">框架-React</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>工程化和协作</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/folder1/webpack.html" class="sidebar-link">Webpack</a></li><li><a href="/pages/folder1/normalize.html" class="sidebar-link">前端规范</a></li><li><a href="/pages/folder1/git.html" class="sidebar-link">Git</a></li><li><a href="/pages/folder1/build.html" class="sidebar-link">构建</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>算法与编程</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/folder1/algorithm-data.html" class="sidebar-link">数据结构和算法-概念</a></li><li><a href="/pages/folder1/algorithm-sort.html" class="sidebar-link">数据结构和算法-排序专题</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="链表"><a href="#链表" class="header-anchor">#</a> 链表</h2> <h3 id="leetcode-206-反转链表"><a href="#leetcode-206-反转链表" class="header-anchor">#</a> LeetCode-206 反转链表</h3> <p>反转一个单链表。</p> <div class="language- extra-class"><pre class="language-text"><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
</code></pre></div><h5 id="法-1-双指针迭代"><a href="#法-1-双指针迭代" class="header-anchor">#</a> 法 1：双指针迭代</h5> <ul><li><p>思路
设置一个前指针 pre 和当前指针 cur，推进直到当前指针 cur 为空，返回 pre，完成反转</p></li> <li><p>实现</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">reverseList</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token punctuation">[</span>pre<span class="token punctuation">,</span> cur<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">null</span><span class="token punctuation">,</span> head<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 0. 一开始pre指向null，cur指向head</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> tmp <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// 1. 临时变量保存当前节点的下一个节点</span>
    cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span> <span class="token comment">// 2. 然后将当前节点的next指向pre</span>
    pre <span class="token operator">=</span> cur<span class="token punctuation">;</span> <span class="token comment">// 3. pre移到cur的位置(前进一步)</span>
    cur <span class="token operator">=</span> tmp<span class="token punctuation">;</span> <span class="token comment">// 4. cur移到tmp的位置(前进一步)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> pre<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>时间复杂度：遍历了一次链表，这将耗费 O(n) 的时间。</li> <li>空间复杂度：O(1)，常数级额外空间。</li></ul> <p><img src="/assets/img/leetcode-206.651f2680.png" alt="leetcode-206"></p> <h2 id="堆栈"><a href="#堆栈" class="header-anchor">#</a> 堆栈</h2> <h3 id="leetcode-20-有效的括号"><a href="#leetcode-20-有效的括号" class="header-anchor">#</a> LeetCode-20 有效的括号</h3> <h5 id="法-1-栈结构-map-保存括号对应关系"><a href="#法-1-栈结构-map-保存括号对应关系" class="header-anchor">#</a> 法 1：栈结构 + map 保存括号对应关系</h5> <ul><li><p>思路
遍历字符串</p> <ul><li>1、遇到左括号，推入栈。</li> <li>2、遇到右括号，和栈顶数据进行匹配，如果匹配，左括号弹出栈，不匹配则返回 false。</li> <li>3、遍历完成，如果栈为空，则返回 true。否则为 false。</li></ul></li> <li><p>实现</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">isValid</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">s</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token string">&quot;)&quot;</span><span class="token operator">:</span> <span class="token string">&quot;(&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;]&quot;</span><span class="token operator">:</span> <span class="token string">&quot;[&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;}&quot;</span><span class="token operator">:</span> <span class="token string">&quot;{&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> c <span class="token keyword">of</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>map<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span>length <span class="token operator">||</span> map<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">!==</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>时间复杂度：O(n)​，进栈出栈是 O(1)，遍历了 1 次含 n 个元素的空间，即 O(1) x n，为 O(n)</li> <li>空间复杂度：O(n)，最坏情况都是左括号会压入栈</li></ul> <h2 id="堆"><a href="#堆" class="header-anchor">#</a> 堆</h2> <h3 id="leetcode-面试-40-最小的-k-个数"><a href="#leetcode-面试-40-最小的-k-个数" class="header-anchor">#</a> LeetCode-面试 40 最小的 k 个数</h3> <h5 id="法-1-排序【适合静态数据集合】"><a href="#法-1-排序【适合静态数据集合】" class="header-anchor">#</a> 法 1：排序【适合静态数据集合】</h5> <ul><li><p>思路
将数组进行排序（可以是最简单的快排），取前 K 个数就可以了，so easy</p></li> <li><p>实现</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">getLeastNumbers</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>时间复杂度：O(nlogn)</li> <li>空间复杂度：O(logn)</li></ul> <h5 id="法-2-大顶堆求-tok-k【更适合动态数据集合】"><a href="#法-2-大顶堆求-tok-k【更适合动态数据集合】" class="header-anchor">#</a> 法 2：大顶堆求 Tok K【更适合动态数据集合】</h5> <ul><li>思路
<ul><li>从数组中取前 k 个数（ 0 到 k-1 位），构造一个大顶堆</li> <li>从 k 位开始遍历数组，每一个数据都和大顶堆的堆顶元素进行比较，如果大于堆顶元素，则不做任何处理，继续遍历下一元素；如果小于堆顶元素，则将这个元素替换掉堆顶元素，然后再堆化成一个大顶堆。</li> <li>遍历完成后，堆中的数据就是前 K 小的数据</li></ul></li> <li>实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">getLeastNumbers</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> heap <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment">// 从 arr 中取出前 k 个数，构建一个大顶堆</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    heap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">buildHeap</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 从 k 位开始遍历数组</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> k<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>heap<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 替换并堆化</span>
      heap<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token function">buildHeap</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 删除heap中第一个元素</span>
  heap<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> heap<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 原地建堆，从后往前，自上而下式建大顶堆</span>
<span class="token keyword">let</span> <span class="token function-variable function">buildHeap</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token comment">// 从最后一个非叶子节点开始，自上而下式堆化</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> k<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 堆化</span>
<span class="token keyword">let</span> <span class="token function-variable function">heapify</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> k<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 自上而下式堆化</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> maxIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">&lt;=</span> k <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      maxIndex <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> k <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>maxIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      maxIndex <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>maxIndex <span class="token operator">!==</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>maxIndex<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>maxIndex<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      i <span class="token operator">=</span> maxIndex<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>时间复杂度：遍历数组需要 O(n) 的时间复杂度，一次堆化需要 O(logk) 时间复杂度，所以利用堆求 Top k 问题的时间复杂度为 O(nlogk)</li> <li>空间复杂度：O(k)</li></ul> <h3 id="leetcode-215-数组中的第-k-个最大元素"><a href="#leetcode-215-数组中的第-k-个最大元素" class="header-anchor">#</a> LeetCode-215 数组中的第 K 个最大元素</h3> <h5 id="法-1-排序"><a href="#法-1-排序" class="header-anchor">#</a> 法 1：排序</h5> <ul><li>思路
<ul><li>先对数组进行排序，再返回倒数第 k 个元素</li> <li>语义是从右边往左边数第 k 个元素，那么从左向右数是第几个呢，我们列出几个找找规律就好了。</li> <li>一共 6 个元素，找第 2 大，索引是 4；</li> <li>一共 6 个元素，找第 4 大，索引是 2。</li> <li>因此，升序排序以后，目标元素的索引是 len - k。</li></ul></li> <li>实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">findKthLargest</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> nums<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> k<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>时间复杂度：O(n logn) 算法的性能消耗主要在排序，n 是数组的长度</li> <li>空间复杂度：O(1) 原地排序，没有借助额外的辅助空间。</li></ul> <h5 id="法-2-小顶堆"><a href="#法-2-小顶堆" class="header-anchor">#</a> 法 2：小顶堆</h5> <ul><li>思路
<ul><li>维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。</li> <li>如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中，并进行堆化。；</li> <li>如果比堆顶元素小，则不做处理，继续遍历数组。</li> <li>这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了，堆顶元素就是第 K 大数据。</li></ul></li> <li>实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>
</code></pre></div><ul><li>时间复杂度：O(nlogK) 遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK) 的时间复杂度，所以最坏情况下，n 个元素都入堆一次.</li> <li>空间复杂度：O(K)，用于存储堆元素。</li></ul> <h2 id="递归"><a href="#递归" class="header-anchor">#</a> 递归</h2> <h3 id="leetcode-50-pow-x-n"><a href="#leetcode-50-pow-x-n" class="header-anchor">#</a> LeetCode-50 Pow(x,n)</h3> <p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p> <p>输入: 2.00000, 10
输出: 1024.00000</p> <p>输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25</p> <h5 id="法-1-快速幂-递归法"><a href="#法-1-快速幂-递归法" class="header-anchor">#</a> 法 1：快速幂+递归法</h5> <ul><li><p>示例</p> <div class="language- extra-class"><pre class="language-text"><code>x→x^2→x^4→x^8→x^16→x^32→x^64
</code></pre></div></li> <li><p>思路</p> <ul><li>边界：0 次方=1，1 次方=x 本身。</li> <li>返回：x 传入 x 的平方，再传入 2 / n 次幂。</li> <li>注意：负幂为倒数，奇数还需要乘多一次 x。</li></ul></li> <li><p>实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">myPow</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 判断小于0为倒数</span>
  <span class="token comment">// 判断=0返回1</span>
  <span class="token comment">// 判断是整数还是奇数，整数为x平方的n/2幂向下取整，奇数为x平方的n/2幂向下取整，再乘x。</span>
  <span class="token comment">// 偶数除以2最终会变成1，也就是奇数，return 1*x ，或者写成n=1时，返回x。</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token function">myPow</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token operator">-</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">myPow</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x<span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">myPow</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x<span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>时间复杂度：O(log n)，即为递归的层数。</p></li> <li><p>空间复杂度：O(log n)，即为递归的层数。这是由于递归的函数调用会使用栈空间。</p></li></ul> <h2 id="二叉树"><a href="#二叉树" class="header-anchor">#</a> 二叉树</h2> <h3 id="leetcode-144-二叉树的前序遍历"><a href="#leetcode-144-二叉树的前序遍历" class="header-anchor">#</a> LeetCode-144 二叉树的前序遍历</h3> <p>给定一个二叉树，返回它的   前序   遍历。</p> <p>示例:</p> <div class="language- extra-class"><pre class="language-text"><code>输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,2,3]
</code></pre></div><h5 id="法-1-递归"><a href="#法-1-递归" class="header-anchor">#</a> 法 1：递归</h5> <ul><li>思路</li> <li>实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">preorderTraversal</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> <span class="token function-variable function">preorder</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">preorder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">preorder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>时间复杂度：O(n)</li> <li>空间复杂度：O(n)</li></ul> <h5 id="法-2-迭代"><a href="#法-2-迭代" class="header-anchor">#</a> 法 2：迭代</h5> <blockquote><p>递归使用调用栈，所以用栈模拟递归的过程</p></blockquote> <ul><li>思路
<ul><li>首先根入栈</li> <li>根节点出栈，将根的 val 值放入 res 中</li> <li>将根的左右节点入栈，入栈顺序是先右后左，保证出栈顺序才是先左后右（符合根左右）</li> <li>左节点出栈，左节点 val 值放入 res</li> <li>如果左节点仍有子节点，则继续入栈。</li> <li>以此类推，直到栈为空，遍历完成。</li></ul></li> <li>实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">preorderTraversal</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    node<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    node<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>时间复杂度：O(n)</li> <li>空间复杂度：O(n)</li></ul> <h3 id="leetcode-145-二叉树的后序遍历"><a href="#leetcode-145-二叉树的后序遍历" class="header-anchor">#</a> LeetCode-145 二叉树的后序遍历</h3> <p>给定一个二叉树，返回它的 后序   遍历。</p> <p>示例:</p> <div class="language- extra-class"><pre class="language-text"><code>输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [3,2,1]
</code></pre></div><h5 id="法-1-递归-2"><a href="#法-1-递归-2" class="header-anchor">#</a> 法 1：递归</h5> <ul><li>思路</li> <li>实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">postorderTraversal</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">order</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token function">order</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">order</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">order</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>时间复杂度：O(n)</li> <li>空间复杂度：O(n)</li></ul> <h5 id="法-2-迭代-倒序解"><a href="#法-2-迭代-倒序解" class="header-anchor">#</a> 法 2：迭代+倒序解</h5> <blockquote><p>如果我们把前序遍历的 list.push(node.val) 变更为 list.unshift(node.val) （遍历结果逆序），那么遍历顺序就由 根左右 变为 右左根，仅需将 右左根 变更为 左右根 即可完成后序遍历</p></blockquote> <ul><li>思路
<ul><li>每次把值都插到数组的最前面</li> <li>每次先入栈左节点, 然后入栈右节点</li></ul></li> <li>实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">postorderTraversal</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    node<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    node<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>时间复杂度：O(n)</li> <li>空间复杂度：O(n)</li></ul> <h3 id="leetcode-94-二叉树的中序遍历"><a href="#leetcode-94-二叉树的中序遍历" class="header-anchor">#</a> LeetCode-94 二叉树的中序遍历</h3> <p>给定一个二叉树，返回它的中序   遍历。</p> <p>示例:</p> <div class="language- extra-class"><pre class="language-text"><code>树结构:
TreeNode: {
  val: 1,
  right: {
    val: 2,
    right: null,
    left: {
      val: 3,
      right: null,
      left: null,
    },
  },
  left: null
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
</code></pre></div><h5 id="法-1-递归法"><a href="#法-1-递归法" class="header-anchor">#</a> 法 1：递归法</h5> <ul><li>思路</li> <li>实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">inorderTraversal</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">order</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token function">order</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">order</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">order</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>时间复杂度：O(n)​ 递归函数 T(n)=2∗T(n/2)+1 ，因此时间复杂度为 O(n)​</li> <li>空间复杂度：O(n)</li></ul> <h5 id="法-2-迭代法"><a href="#法-2-迭代法" class="header-anchor">#</a> 法 2：迭代法</h5> <ul><li><p>思路</p> <ul><li>声明一个临时堆栈存放左子节点和 result 存放结果，一直向下查找，找到有 node.left 存在，则 push 进临时堆栈中，continue 继续判断有无 left，直到查不到左子节点。</li> <li>开始处理刚才插入的左子节点，类似堆栈，pop 弹出最后插入的 node，把 node.val 值推入 result 结果数组中。（循环判断条件要加上堆栈不为空，只要不为空，就还得继续执行弹出操作）</li> <li>将该节点的右节点作为下一次迭代对象。最后返回 result。</li></ul></li> <li><p>实现</p> <ul><li>取根节点为目标节点，开始遍历</li> <li>1.左孩子入栈 -&gt; 直至左孩子为空的节点</li> <li>2.节点出栈 -&gt; 访问该节点</li> <li>3.以右孩子为目标节点，再依次执行 1、2、3</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">inorderTraversal</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">||</span> stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
      root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    root <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>时间复杂度：O(n) 查询所有节点需要 O(n)的时间</li> <li>空间复杂度：O(n) 创建了长度为 n 的数组</li></ul> <h2 id="广度搜索"><a href="#广度搜索" class="header-anchor">#</a> 广度搜索</h2> <h3 id="leetcode-102-二叉树的层序遍历"><a href="#leetcode-102-二叉树的层序遍历" class="header-anchor">#</a> LeetCode-102 二叉树的层序遍历</h3> <p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
示例：
二叉树：[3,9,20,null,null,15,7],</p> <div class="language- extra-class"><pre class="language-text"><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre></div><p>返回其层次遍历结果：</p> <div class="language- extra-class"><pre class="language-text"><code>[
  [3],
  [9,20],
  [15,7]
]
</code></pre></div><h5 id="法-1-bfs"><a href="#法-1-bfs" class="header-anchor">#</a> 法 1：BFS</h5> <ul><li>思路
<ul><li>初始化 queue，用于存储当前层的节点，一开始存储根节点</li> <li>检查 queue 是否为空</li> <li>如果不为空：依次遍历当前 queue 内的所有节点，将 node.val 的值存入 arr 中，再检查每个节点的左右子节点，将不为空的子节点放入 queue，继续循环</li> <li>如果为空：跳出循环</li> <li>每层 queue 循环结束，将每层将 res.push(arr)，最后返回 res</li></ul></li> <li>实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">levelOrder</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> len <span class="token operator">=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
      len<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>时间复杂度：O(n)</li> <li>空间复杂度：O(n)
<img src="/assets/img/leetcode-102.298de0cd.png" alt="leetcode102"></li></ul> <h2 id="深度搜索"><a href="#深度搜索" class="header-anchor">#</a> 深度搜索</h2> <h3 id="leetcode-101-对称二叉树"><a href="#leetcode-101-对称二叉树" class="header-anchor">#</a> LeetCode-101 对称二叉树</h3> <p>给定一个二叉树，检查它是否是镜像对称的。</p> <p>例如，二叉树  [1,2,2,3,4,4,3] 是对称的。</p> <div class="language- extra-class"><pre class="language-text"><code>    1
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre></div><p>但是下面这个  [1,2,2,null,3,null,3] 则不是镜像对称的:</p> <div class="language- extra-class"><pre class="language-text"><code>    1
   / \
  2   2
   \   \
   3    3
</code></pre></div><h5 id="法-1-dfs"><a href="#法-1-dfs" class="header-anchor">#</a> 法 1：DFS</h5> <ul><li>思路
<ul><li>判断根节点为空的话，返回 true；</li> <li>返回递归根节点的左右子树</li> <li>递归函数里判断左右节点是否为空，空的话对应的位置也要为空才返回 true；</li> <li>如果都不为空则判断值是否相等，如果不等，返回 false；</li> <li>相等继续递归下去，（左节点的右孩子和右节点的左孩子）&amp;&amp; （左节点的左孩子和右节点的右孩子）这两个条件都为 true 才是对称二叉树。</li></ul></li> <li>实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">isSymmetric</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">isSameTree</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">r<span class="token punctuation">,</span> l</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> l <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> r <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span>val <span class="token operator">!==</span> l<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>left<span class="token punctuation">,</span> l<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>right<span class="token punctuation">,</span> l<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>时间复杂度：O(n)​ 我们需要对这个树中的每个节点都要进行遍历</li> <li>空间复杂度：O(n)​ 当树是线性时，由栈上的递归调用造成的空间复杂度为 O(n)</li></ul> <h3 id="leetcode-104-二叉树的最大深度"><a href="#leetcode-104-二叉树的最大深度" class="header-anchor">#</a> LeetCode-104 二叉树的最大深度</h3> <p>给定一个二叉树，找出其最大深度。</p> <p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p> <p>说明:  叶子节点是指没有子节点的节点。
示例：
给定二叉树 [3,9,20,null,null,15,7]，</p> <div class="language- extra-class"><pre class="language-text"><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre></div><p>返回它的最大深度  3 。</p> <h5 id="法-1-dfs-2"><a href="#法-1-dfs-2" class="header-anchor">#</a> 法 1：DFS</h5> <ul><li>思路
<ul><li>判断二叉树是否为空，空的直接返回 0，结束，非空二叉树继续</li> <li>分别递归计算左右子树的最大深度</li> <li>返回左子树深度和右子树最大深度的最大值 + 1，就是整个树的最大深度。</li></ul></li> <li>实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">maxDepth</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> left <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> right <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>时间复杂度：O(n) 通过递归的方式查询了数的所有子节点。查询花费 O(n) 的时间</li> <li>空间复杂度：O(n) 每次递归都需要创建新的临时空间，空间复杂度 O(n)
<img src="/assets/img/leetcode-104.0116cb68.png" alt="leetcode104"></li></ul> <h3 id="leetcode-108"><a href="#leetcode-108" class="header-anchor">#</a> LeetCode-108</h3> <h2 id="动态规划"><a href="#动态规划" class="header-anchor">#</a> 动态规划</h2> <h3 id="leetcode-70-爬楼梯"><a href="#leetcode-70-爬楼梯" class="header-anchor">#</a> LeetCode-70 爬楼梯</h3> <p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p> <p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p> <p>注意：给定 n 是一个正整数。
示例 1：</p> <div class="language- extra-class"><pre class="language-text"><code>输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
</code></pre></div><p>示例 2：</p> <div class="language- extra-class"><pre class="language-text"><code>输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
</code></pre></div><h5 id="法-1-动态规划"><a href="#法-1-动态规划" class="header-anchor">#</a> 法 1：动态规划</h5> <blockquote><p>dp 状态定义（f(n)表示到第 n 阶的总走法个数）、dp 方程写出来</p></blockquote> <ul><li><p>思路</p> <ul><li>本问题其实常规解法可以分成多个子问题，爬第 n 阶楼梯的方法数量，等于 2 部分之和
<ul><li>1、爬上 n-1 阶楼梯的方法数量。因为再爬 1 阶就能到第 n 阶</li> <li>2、爬上 n-2 阶楼梯的方法数量。因为再爬 2 阶就能到第 n 阶</li></ul></li> <li>所以我们得到公式 dp[n] = dp[n-1] + dp[n-2]</li> <li>同时需要初始化 dp[1]=1 和 dp[2]=2</li></ul></li> <li><p>实现</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">climbStairs</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  result<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> result<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> result<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>时间复杂度：O(n)，对 n 进行了一次循环遍历，运行次数与输入 n 成正比</li> <li>空间复杂度：O(n)，创建了一个长度为 n 的空间，空间复杂度是 O(n)</li></ul> <h5 id="法-2-递归-记忆化"><a href="#法-2-递归-记忆化" class="header-anchor">#</a> 法 2：递归+记忆化</h5> <ul><li>思路
f（n）= f（n-1）+f（n-2）</li> <li>实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 递归函数（无记忆）</span>
<span class="token keyword">const</span> <span class="token function-variable function">climbStairs</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 递归函数（记忆化）</span>
<span class="token keyword">const</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">,</span> map</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> map<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> map<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fn</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> map<span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>
    <span class="token keyword">return</span> num<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">climbStairs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> map<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>时间复杂度：
<ul><li>递归（无记忆）为 O(2^n)​；每个节点都要计算，为二叉树的节点 O(2^n - 1)​</li> <li>递归（记忆化）为 O(n)​；避免了重复计算，为二叉树高度 O(n)​</li></ul></li> <li>空间复杂度：O(n)</li></ul> <h3 id="leetcode-121-买卖股票的最佳时机"><a href="#leetcode-121-买卖股票的最佳时机" class="header-anchor">#</a> LeetCode-121 买卖股票的最佳时机</h3> <p>给定一个数组，它的第  i 个元素是一支给定股票第 i 天的价格。</p> <p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p> <p>注意：你不能在买入股票前卖出股票。
示例 1:</p> <div class="language- extra-class"><pre class="language-text"><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
</code></pre></div><p>示例 2:</p> <div class="language- extra-class"><pre class="language-text"><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre></div><h5 id="法-1-一次遍历法"><a href="#法-1-一次遍历法" class="header-anchor">#</a> 法 1：一次遍历法</h5> <ul><li>思路
<ul><li>设置【最低价格】minPrice，再设置【最大收益】maxProfit。</li> <li>然后遍历价格数组，如果当天价格比最小价格更低，则将当天价格赋值给最小价格。</li> <li>每天计算：之前的历史最低价格与当天价格的差值收益，和前面的最大收益比较。</li> <li>若差值大于最大收益，则将差值赋值给最大收益，否则不处理。</li> <li>最后遍历一遍即可获得最大收益 maxProfit。</li></ul></li> <li>实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">maxProfit</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">prices</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> minPrice <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> maxProfit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prices<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 初始化最小价格为第一个元素</span>
      minPrice <span class="token operator">=</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> minPrice<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 遍历过程中发现最小价格，则重新赋值</span>
      minPrice <span class="token operator">=</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> minPrice <span class="token operator">&gt;</span> maxProfit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 比较当日卖出收益与当前已获取的最大收益</span>
      maxProfit <span class="token operator">=</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> minPrice<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> maxProfit<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>时间复杂度：O(n)</li> <li>空间复杂度：O(1)，在算法中，我们使用两个公共变量保存最大收益以及最小卖出价格，所以空间复杂度为常数级。</li></ul> <h5 id="法-2-动态规划"><a href="#法-2-动态规划" class="header-anchor">#</a> 法 2：动态规划</h5> <ul><li>思路
<ul><li>设置【每日最大收益数组】profits，并初始化第一天为 0；再设置【最大收益】maxProfit；</li> <li>遍历价格数组，计算每日可获取的最大收益值，每日有两种情况，取二者的最大值。
<ul><li>一种是买入：最大收益为 0；</li> <li>一种是卖出，最大收益为【前一天的最大收益】+【前一天和今天的价格差值（就是上涨/下跌多少）】（等于说昨天不卖等到今天卖，是亏了还是赚更多了）</li></ul></li> <li>计算完每日的最大收益，和 maxProfit 进行比较，若大于 maxProfit，就将最大收益赋值给 maxProfit，最终遍历完成，可得到最大收益。</li></ul></li> <li>实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">maxProfit</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">prices</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> profits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> maxProfit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prices<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    profits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> profits<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>profits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> maxProfit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      maxProfit <span class="token operator">=</span> profits<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> maxProfit<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>时间复杂度：O(n)​</li> <li>空间复杂度：O(n)​</li></ul> <h3 id="leetcode-53-最大子序和"><a href="#leetcode-53-最大子序和" class="header-anchor">#</a> LeetCode-53 最大子序和</h3> <p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例:</p> <div class="language- extra-class"><pre class="language-text"><code>输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
</code></pre></div><h5 id="法-1-动态规划-2"><a href="#法-1-动态规划-2" class="header-anchor">#</a> 法 1：动态规划</h5> <blockquote><p>动态规划的难点在于找到状态转移方程，dp[i] —— 表示到当前位置 i 的最大子序列和</p></blockquote> <ul><li>思路
<ul><li>状态转移方程为： dp[i] = max(dp[i - 1] + nums[i], nums[i])</li> <li>初始化：dp[0] = nums[0]</li></ul></li></ul> <p>从状态转移方程中，我们只关注前一个状态的值，所以不需要开一个数组记录位置所有子序列和，只需要两个变量，currMaxSum 保存前一位的最大和，给数组后面判断是否要加上自身的数值。</p> <ul><li><p>currMaxSum - 累计到当前位置 i 的最大和，因为要保存当前位置的最优状态，所以赋值给 nums[i]</p></li> <li><p>maxSum - 全局最大子序列和，如果 currMaxSum 比当前 maxSum 大，赋值给 maxSum。 - currMaxSum(nums[ i ]) = max(currMaxSum(nums[i - 1]) + nums[i], nums[i]) - maxSum = max(currMaxSum, maxSum)
<img src="/assets/img/leetcode-53.1ebaf0bd.png" alt="leetcode53"></p></li> <li><p>实现</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">maxSubArray</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token keyword">let</span> max <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      max <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> max<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 经过上面一顿赋值，传入的数组已变成currMaxSum，每个位置是当前的最大和。</span>
<span class="token comment">// 由于位置可选，所以保存在max中的才是全局最大和。</span>
</code></pre></div><ul><li>时间复杂度：O(n)，n 是数组长度</li> <li>空间复杂度：O(1)</li></ul> <h5 id="法-2-暴力法"><a href="#法-2-暴力法" class="header-anchor">#</a> 法 2：暴力法</h5> <blockquote><p>从数组最左边开始于数组右边数据依次相加，将相加之后数据进行比较，比较之后最大值为最终结果</p></blockquote> <ul><li><p>思路</p> <ul><li>创建临时变量 sum 和最大值 maxNumber</li> <li>从数组子序列左端开始遍历依次取数据</li> <li>从数组子序列右端开始遍历</li> <li>依次取右端某个节点数据和夹在中间的数值依次相加</li> <li>将相加之后值与最大值 sum 进行比较，大的值赋值与 maxNumber</li> <li>最终获得最大值</li></ul></li> <li><p>实现</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">maxSubArray</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> maxNumber <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 从数组子序列左端开始</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 从数组子序列右端开始</span>
      sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token operator">=</span> i<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 暴力计算</span>
        sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&gt;</span> maxNumber<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        maxNumber <span class="token operator">=</span> sum<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> maxNumber<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>时间复杂度：O(n^3) 对于每个元素，通过三次遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n^3) 的时间。</li> <li>空间复杂度：O(1)</li></ul> <h2 id="贪心算法"><a href="#贪心算法" class="header-anchor">#</a> 贪心算法</h2> <h3 id="leetcode-122-买卖股票的最佳时机-ii"><a href="#leetcode-122-买卖股票的最佳时机-ii" class="header-anchor">#</a> LeetCode-122 买卖股票的最佳时机 II</h3> <p>给定一个数组，它的第  i 个元素是一支给定股票第 i 天的价格。</p> <p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p> <p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
示例 1:</p> <div class="language- extra-class"><pre class="language-text"><code>输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
</code></pre></div><p>示例 2:</p> <div class="language- extra-class"><pre class="language-text"><code>输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
</code></pre></div><p>示例  3:</p> <div class="language- extra-class"><pre class="language-text"><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre></div><p>提示：
1 &lt;= prices.length &lt;= 3 * 10 ^ 4
0 &lt;= prices[i] &lt;= 10 ^ 4</p> <h5 id="法-1-贪心算法"><a href="#法-1-贪心算法" class="header-anchor">#</a> 法 1：贪心算法</h5> <blockquote><p>由于我们是想获取到最大的收益，我们的策略应该是低点买入，高点卖出。由于题目对于交易次数没有限制，因此只要能够赚钱的机会我们都不应该放过。</p></blockquote> <blockquote><p>如下图，我们只需要求出加粗部分的总和即可
<img src="/assets/img/leetcode-122.62787331.png" alt="leetcode122"></p></blockquote> <ul><li>思路
<ul><li>例子【1，2，3，4，5】</li> <li>判断明天比今天高，就今天买入，明天卖出，每天都这么判断，这样每天锁定 1 块钱收益，因为特殊条件存在（无手续费也没有交易次数限制），所以每天买卖和一直持股到最后才卖，收益是一样的，都是 4 块收益。</li></ul></li> <li>实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">maxProfit</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">prices</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> profit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prices<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      profit <span class="token operator">=</span> profit <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> profit<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>时间复杂度：O(n)</li> <li>空间复杂度：O(1)</li></ul> <h2 id="回溯算法"><a href="#回溯算法" class="header-anchor">#</a> 回溯算法</h2> <h3 id="leetcode-22-括号生成"><a href="#leetcode-22-括号生成" class="header-anchor">#</a> LeetCode-22 括号生成</h3> <p>数字 n  代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p> <p>示例：</p> <div class="language- extra-class"><pre class="language-text"><code>输入：n = 3
输出：[
       &quot;((()))&quot;,
       &quot;(()())&quot;,
       &quot;(())()&quot;,
       &quot;()(())&quot;,
       &quot;()()()&quot;
     ]
</code></pre></div><h5 id="法-1-深度优先遍历-dfs"><a href="#法-1-深度优先遍历-dfs" class="header-anchor">#</a> 法 1：深度优先遍历 DFS</h5> <blockquote><p>深度优先搜索(回溯思想)，从空字符串开始构造，做加法。
<img src="/assets/img/leetcode-22.96bb7a10.png" alt="LeetCode-22"></p></blockquote> <ul><li>思路
<ul><li>在左边和右边的括号数都等于 n 的时候结算。</li> <li>左边括号数小于右边，进行剪枝，return 不递归。</li></ul></li> <li>实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">generateParenthesis</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token parameter">l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">===</span> n <span class="token operator">&amp;&amp;</span> r <span class="token operator">===</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// l 小于 r 时不满足条件 剪枝</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// l 小于 n 时可以插入左括号，最多可以插入 n 个</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">dfs</span><span class="token punctuation">(</span>l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> str <span class="token operator">+</span> <span class="token string">&quot;(&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// r &lt; l 时 可以插入右括号</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> l<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">dfs</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> str <span class="token operator">+</span> <span class="token string">&quot;)&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>时间复杂度：O(2^N)</li> <li>空间复杂度：O(2^N)</li></ul> <h3 id="leetcode-46-全排列"><a href="#leetcode-46-全排列" class="header-anchor">#</a> LeetCode-46 全排列</h3> <p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p> <p>示例:</p> <div class="language- extra-class"><pre class="language-text"><code>  输入: [1,2,3]
  输出:
  [
    [1,2,3],
    [1,3,2],
    [2,1,3],
    [2,3,1],
    [3,1,2],
    [3,2,1]
  ]
</code></pre></div><h5 id="法-1-回溯算法"><a href="#法-1-回溯算法" class="header-anchor">#</a> 法 1：回溯算法</h5> <ul><li>思路
解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考 3 个问题：</li></ul> <p>1、「路径」，记录你已经做过的选择；
2、「选择列表」，表示你当前可以做出的选择
3、「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候。</p> <p>核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」，就能正确得到每个节点的选择列表和路径。
<img src="/assets/img/leetcode-46.9732f159.jpg" alt="LeetCode-46"></p> <ul><li>实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">permute</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">back</span><span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span>length <span class="token operator">===</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拷贝结果到res数组</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 递归出口</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      path<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归调用</span>
      path<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 下层遍历结束或者满足条件返回，进行回退。</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 开始执行</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>有时候需要回退两步，在代码中体现就是一次循环遍历结束，当时的 back 函数执行完毕，继续执行 pop，将选择撤销一步，回到上层循环，继续选择未遍历的其他分枝。</p></blockquote> <ul><li>时间复杂度：O(n×n!)</li> <li>空间复杂度：O(n!)</li></ul> <h2 id="模板"><a href="#模板" class="header-anchor">#</a> 模板</h2> <h3 id="leetcode"><a href="#leetcode" class="header-anchor">#</a> LeetCode-</h3> <h5 id="法-1"><a href="#法-1" class="header-anchor">#</a> 法 1：</h5> <ul><li>思路</li> <li>实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>
</code></pre></div><ul><li>时间复杂度：</li> <li>空间复杂度：</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d50c72b0.js" defer></script><script src="/assets/js/2.7285e602.js" defer></script><script src="/assets/js/11.7a5bbaab.js" defer></script>
  </body>
</html>
